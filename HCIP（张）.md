# IP

## 第一天：复习为主

跨区域的PC传输抽象语言（文字，图片，视频）--- 电脑无法识别抽象语言，只能识别电信号 --- 转换（抽象语言 <---> 电信号）--- 抽象语言转编码，编码转二进制，二进制转电信号

OSI参考模型 --- OSI/RM --- 开发式系统互联参考模型
ISO --- 国际标准化组织 --- 1979

###### 七层模型

```shell
应用层 
	提供各种应用服务，抽象语言转编码

表示层 
	将编码转化为二进制

会话层 
	维持网络应用和网络服务器之间的会话连接

传输层 
	实现端到端的传输(应用到应用之间的传输)，端口号（传输层的地址）-> 区分和标定不同的应用（16位二进制构成）--- 1-65535（0端口不用，1-1023为知名端口号，用来标定也知服务）--- sport，dropt <源端口号，目标端口号（具体值）>

网络层 
	实现主机间的逻辑寻址 IP地址（逻辑地址 -- 可以变化的地址，IP地址本身就是为了区分和标定不同的广播域，设备在不同的广播域使用不同的IP地址标定）--- SIP,DIP（源ip，目标ip）
		如何获取对端ip地址：	
			-1.直接知道对方的ip地址 
			-2.通过域名获取对方的ip地址
			-3.通过ARP或应用程序访问服务器（相当于内嵌ip地址）
			-4.通过广播获取

数据链路层 
	控制物理硬件，将二进制转换为电信号 --- MAC --- 所有芯片出厂时刻制的（固定的物理地址，48位二进制 -- 1.全球唯一2.格式唯一） -- SMAC.DMAC(实现主机间物理地址寻址)
		获取目标MAC地址方法：
			ARP协议 -- 地址解析协议 -- 通过一种地址获取另一种地址
			APR分类：
				正向ARP -- 已知目标ip地址，获取目标MAC地址
					过程：PC通过广播形式发送ARP请求，通过IP地址请求MAC地址，由于广播帧，所以该广播的所有设备都会收到这个请求，设备收到后，先将数据包中的源IP和源MAC对应关系记录在本地的ARP缓存表。然后再看请求IP地址，如果请求不是自己的IP地址，则直接丢弃该数据包；如果是，则应答。然后，再通讯，优先查看本地  ARP表格，有记录则按照记录中的MAC地址添加；若不存在，则再发ARP请求获取。
				反向ARP -- 已知目标MAC，获取对方IP地址
				免费ARP -- 利用正向ARP工作原理，请求自己的IP地址
					作用：1.自我介绍；2.检测地址冲突
				代理ARP -- 激活后，路由器查看收到的ARP请求包，基于ARP请求的IP地址查看路由表，若本地路由可达，则冒充对端IP回复ARP应答。将MAC地址写成自己的MAC地址，之后数据发到本路由器上，再帮助转发

物理层 
	处理和传递电信号
```

###### TCP/IP模型

​	

```shell
TCP/IP协议簇 --- 分层   
	划分太细
TCP/IP四层模型 --- TCP/IP标准模型
TCP/IP五层模型 --- TCP/IP对等模型

TCP和OSI区别
	--- 网络层只包含互联网（而OSI的网络层包括所有的网络）
	--- TCP/IP模型支持跨层封装
	--- TCP/IP一般应用于直连设备之间的近距离通讯
	
PDU --- 协议数据单元
L1 PDU -- L2 PDU - L3 PDU  ... ... L7 PDU

应用层 	--- 报文
传输层 	--- 段
网络层 	--- 包
数据链路层  --- 帧
物理层 	--- 比特流
封装 		 --- 解封装

封装和解封装
把数据从应用层到数据链路层的加工为封装，反过来就是解封装
封装 --- 将每一层重要的数据加到原始的数据中，来实现这一层的功能

应用层 -- 应用进行封装，封装方式取决于不同应用
传输层 -- 封装端口号 - TCP和UDP
网络层 -- 封装ip地址 - ip协议
数据链路层 -- 封装Mac地址 - 以太网协议

跨层封装主要存在的两种形式：
	1.跨四层封装 -- OSPF 
	2.跨三层，四层封装
	TCP -- 6
	UDP -- 17
	协议号 -- 8位二进制构成 --- 0-255 可以用来标定跨层封装的上层协议
	OSPF -- 协议对应号为 89

数据分段 MTU（最大传输单元）和MUA
	二类帧和3.0帧
		SOF 帧首定界符
		MAC 介质访问控制层 
		LLC 逻辑链路控制层 -- 提供分片和标定数据类型号作用
```

IP地址 --- IP协议（互联网协议）

```shell
IPV4 --- 32位二进制 点分十进制
	分为两部分 -- 一部分网络位，一部分主机位 
		子网掩码（1.连续0和1,1为网络位，0为主机位 2.网络位相同，代表同一个广播域；网络位不同，代表在不同广播域）
		A,B,C 单播地址 D 组播地址 E 保留地址
		特殊ip地址：127.0.0.0/8 --- 环回地址
		255.255.255.255 --- 受限广播地址（受路由器限制）
		0.0.0.0 --- 1.任意地址 2.没有地址
		主机位全1 --- 直接广播地址
		主机位全0 --- 代表一个范围网段
		169.254.0.0/16 --- 本地链路地址/自动私有地址
		
IPV6 --- 128位二进制 冒分十六进制

VLSM --- 可变长子网掩码

CIDR --- 无类域间路由
```

## 第二天：静态+动态综合

###### 静态路由的基本配置

```shell
方法一：[r1]ip route-static 192.168.3.0 24 192.168.2.2 --- 直接
写下一跳 --- #需要递归查找出接口   
			#适用于LA网络
[r2-GigabitEthernet0/0/0]arp-proxy enable --- 激活接口代理
ARP的功能
代理ARP --- ARP一种类型，激活后，路由器将查看收到的ARP请求
包，基于ARP请求的IP地址查看路由表，若本地路由可达，则将冒充
对方IP给请求者回复ARP应答。将MAC地址写成自己的MAC地址，之后
数据发到本路由器上，再帮忙进行转发。
方法二：[r1]ip route-static 192.168.3.0 24 GigabitEthernet 
0/0/1 ---- 只写出接口 ---- 需要激活路由器的代理ARP功能
			#适用于点到点网络，和方法一不同的是，这个方法不会递归查找出接口
方法三：[r1]ip route-static 192.168.3.0 24 GigabitEthernet 0/0/1 
192.168.2.2 --- 直接写好下一跳和出接口
方法四：[r1]ip route-static 192.168.4.0 24 192.168.3.2 --- 直接
写下两跳，但是需要递归查找，必须提前将递归的路由写好才行
```

###### 静态路由配置

```shell
负载均衡 --- 多条路由开销相似 --- 流量拆分后，多条路径同时传出(叠加带宽效果)
手工汇总 --- 路由存在连续的网段时，可以汇总产生一个总路由条目，提高效率，减少路由条目
路由黑洞 --- 汇总中，会产生不存在的网段，使得流量浪费(无法传递)
缺省路由 --- 一条不限定的路由条目(若在查表时，未有匹配项，则匹配缺省路由)
空接口路由 --- 防路由黑洞和缺省路由成环
				1.路由表匹配原则：最长掩码匹配
				2.空接口作用：匹配到该路由的数据包直接被丢弃
浮动静态路由 --- 修改静态路由默认优先级，实现链路备份
```

###### 一次Web访问过程

```shell
1.PC通过物理网线连接到校园网(无线/有线)
2.PC运行DHCP协议，从本地的DHCP服务器获取一个IP地址
	①：PC做为客户端发出DHCP-discover向服务器申请IP地址(服务器为路由器，客户端为PC)  
	DHCP-discover包：传输层-sport为68，dport为67，
					 网络层-Sip为0.0.0.0，Dip为全255.255.255.255，
					 数据链路层-SMac为PC的Mac，DMac为全F
		数据包先通过传输介质到交换机，交换机查看源Mac，源Mac为PC的地址，并将其记录在交换机的本地MAC地址表中。再去查看目标Mac，目标Mac为全F则泛洪(发送广播信号，除发送的设备，都会收到这个数据包)
		数据包到达了路由器，先看二层广播地址，由于是广播帧，拆二层看三层，三层的目标IP为255.255.255.255，此时路由器解三层封装。根据三层封装中的协议号判断该数据交给UDP模块处理，UDP基于目标端口号为67判断此数据寻找DHCP服务，将交于DHCP服务进行后续。此时DHCP服务器收到DHCP客户端请求
	②：DHCP服务器收到DHCP客户端请求，回复DHCP-offer包(单播/广播)
		包中携带可分配网段中的一个可用IP地址(DHCP地址池的可分配IP地址，还包括网关，DNS地址)
	③：DHCP客户端进行选择(从服务端发送的IP地址)，并回复DHCP-Request --- 回复DHCP-offer --- request包为广播包 
		为什么是广播包：a.回应发送ip的DHCP服务端，获取它的ip地址，
		b.告诉广播域其他的DHCP服务器，自己请求ip地址已被使用，可以进行地址释放
		DHCP收到多个DHCP-offer，选择第一个收到的请求
	④：DHCP服务器发送DHCP-ACK包进行最终的确认 --- 单播/广播
		允许PC客户端使用这个ip地址
3.此时PC已经具备访问服务器的条件,将在浏览器中输入www.geogle.com的URL
4.因为输入的是域名信息，但是访问服务器需要ip地址信息，使用电脑会产生一个DNS请求
		DNS协议请求查找方法： ---> 递归查找+迭代查找
				递归查找：电脑向本地DNS服务器发送查找请求
				迭代查找：本地DNS服务器发送的查找请求
		传输层：UDP DPort：53
		网络层：SIP ： PC的ip 目标ip为网关
		数据链路层： SM：自己的Mac 目标Mac未知
5.为了请求目标的Mac地址，电脑先以网关IP为请求IP，发送一个ARP请求包
		源ip：PC的ip 目标ip：网关
			主机广播发送ARP请求，通过IP请求Mac地址，广播帧 --- 广播域所以设备接收这个请求
			工作过程：首先，主机通过广播的形式发送ARP请求，通过IP地址请求MAC地址。因为是广播帧，所以，广播域内所有的设备均会收到这个请求，设备收到后，先将数据包数据包中的源IP和源MAC的对应关系记录在自己本地的ARP缓存表中。然后，再看请求的IP地址，如果请求的不是自己的IP地址，则将直接丢弃数据包。如果请求的是自己的IP的地址，则进行应答。之后，再进行通讯时，将优先查看本地的ARP缓存表，若有记录，则按照记录中的MAC地址添加；若不存在记录，则再发ARP请求获取。通过ARP请求，电脑将获得网关的MAC地址
6.DNS请求包正常封装
		传输层：UDP Dport:53
		网络层：SIP:本机ip  目标ip：网关
		数据链路层：SMac -- 本机PC  DMac -- 网关的Mac
7.网关收到电脑发送的DNS请求的数据报，
		看二层的MAC地址，目标MAC是自己的MAC，则将解二层封装，看三层。基于三层的目标IP地址去查看本地的路由表。如果存在可以匹配上的路由条目，则将按照路由条目的指示来进行转发。如果不存在，则将直接丢弃该数据报。
8.路由器转发
		该请求报将来到本地的DNS服务器上。如果本地的DNS服务器的缓存中存在该域名对应的IP地址，则将直接返回给电脑。
		如果没有，则将向DNS根服务器发起迭代查找请求，最终获取到该域名对应的IP地址，返回给电脑。
			#迭代查找时使用的是TCP的53号端口
9.PC通过DNS协议获得www.google.com所对应的IP地址信息
	触发本地电脑到目标服务器的HTTP关系的建立。因为HTTP协议是基于TCP协议来进行工作的，所以，需要先完成电脑和目标服务器之间的TCP会话连接（三次握手）。当TCP会话建立之后，客户端和服务器将建立双向的会话通道，将可以相互发送信息。
10.客户端 ---- 服务器：
	发送Http请求 ---- 获取网页信息 ---- GET
11.服务器 ---- 客户端：
	返回网页信息（200OK） ---- 至此电脑上将获取到谷歌web服务器的页面信息
```

###### 动态路由

```shell
	相比静态路由，动态路由可以基于拓扑变化而收敛，使得动态路由更适用于复杂的大型网络。动态路由有其他的问题，为安全和资源占用，依靠算法的路由，会存在选路不佳的情况
	
	动态路由分类
	范围(AS -- 自治系统)
		#IFP -- 内部网关协议 -- 应用在AS内部的路由协议
			-- RIP , OSPF , IS-IS , EIGPR ... ... 
		#EGP -- 外部网关协议 -- 应用在AS外部的路由协议
			-- BGP(边界网关协议)
	IGP协议根据算法进行分类
		-- #距离矢量型协议(DV) 通过直接发送条目信息来获取未知网段的路由信息
				-- 贝尔曼*福特算法  依据传闻的路由协议
				-- RIP
		-- #链路状态型协议(LS)  传递的是拓扑信息(LSA 链路状态通告) -- 收集LSA信息最终将网络完整的拓扑信息获取到
				-- 最短路径优先算法(SPF) -- 将图形结构转化为树形结构 -- 之后再根据树形结构计算出本地到达未知网段的路由信息
				-- OSPF,IS-IS
```

### RIP

```shell
RIP -- 路由信息协议
	算法：贝尔曼*福特算法
	开销：跳数(RIP的工作半径为15，当路由开销值达到16跳时，则认为该路径不可达)
	RIP协议在传递信息仅携带两个参数，一个是目标网段，一个是开销值(开销值COST = 本地路由表中该网段的开销值 + 1)
	版本：RIPv1，RIPv2 -- IPV4
		 RIPNG -- IPV6领域
		 v1和v2的区别：
		 1.v1为有类别路由协议，v2为无类别协议协议   --- 类别：A,B,C... ...等主类网络
		 	v1传播时不携带子网掩码(V1根据网段的主类网来区分mask)
		 	v2携带子网掩码(V2通过携带的掩码来标定mask)
		 	#因此，RIPv1不支持非连续子网掩码 --- eg：两个A类网通过rip被一个路由汇总为一个大的A类网 -- 网络黑洞 1.0.1.0/24 和1.0.2.0/24 会被汇总为1.0.0.0/8 --- 错发(发给1.0的被发给为2.0)
		 	#rip还有等开销负载均衡 --- 导致发给1.0.1.0/24的信息等开销发给1.0.0.0/8这个大网段
		 	#ripv1也无法去支持子网划分和子网聚合
		 2.v1采用广播形式进行邻居通信，v2通过组播(224.0.0.9)进行邻居通信  
		 	#组播以224.0.0.X为类型 --- 本地链路组播 -- 特点:TTL为1 
		 		# --- TTL=1 只能在一个广播域传播 -- 好处
		 		# --- 减少路由资源占用(组播传输有自己的DMac和Dip)
		 		#RIPv1和RIPv2为UDP的520端口进行通信
		 		#RIPng是基于UDP的521端口进行通信
		 3.ripv2支持手动认证和手工汇总，ripv1不支持
	RIP的数据包：
    	request(请求)包 -- RIP运行，希望尽快从邻居处获取未知网段的路由信息
    	Respone(应答)包 -- 携带路由信息的数据包
   		#RIP每隔30s发一次Respone(应答)包 -- RIP的周期更新
   			# -- 作用：弥补保活机制和确认机制
   			#周期更新 --- 为异步周期更新 -- 30s周期更新计时器，保证异步周期更新，RIP没有严格按照30s周期更新，而是在改时间上增加一个小的偏移量+/-5s
   	RIP的计时器：
		1.周期更新计时器：默认30s
		2.失效计时器：180s -- 一条路由信息180s未刷新，则判定该路由失效
			#路由器会将该路由从全局路由表删除，还会保存在缓存中，将其开销值置为16，之后更新仍然携带 -- 带毒传输
		3.垃圾回收计时器：120s -- 失效路由在120s内继续发出，带毒传输。当计时器归零后(120s)，该路由彻底删除
```

###### 贝尔曼*福特算法

```shell
1.R1收到R2发送的2.2.2.0/24网段的信息，但是R1本地路由表没有该网段的路由信息，则直接将该路由刷新到R1的路由

2.R1收到R2发送的2.2.2.0/24网段的信息，但是R1本地路由表中有该网段的路由信息；
则查看下一跳，本地路由表中的下一跳就是R2；这种情况下，将直接将R2发送的路由信息刷新到路由表中

3.R1收到R2发送的2.2.2.0/24网段的信息，但是R1本地路由表中有该网段的路由信息；
则查看下一跳，本地路由表中的下一跳不是R2；这个时候比较开销值。
若本地开销值大于R2发来的路由开销值，则将R2发的路由信息刷新到路由表中。

4.R1收到R2发送的2.2.2.0/24网段的信息，但是R1本地路由表中有该网段的路由信息；
则查看下一跳，本地路由表中的下一跳不是R2；这个时候比较开销值。
若本地开销值小于R2发来的路由开销值，则不刷新R2发送的路由信息。
```

###### rip的环路问题 -- 异步周期更新导致

```shell
如果R2的某条直连网段挂掉，此时R2发送一个cost16的2.0/24网段
但是这个时候R1发送来2.0/24的刷新信息cost2的R1
此时根据贝尔曼*福特算法，第三条，此时cost16无法发出，而被R1刷新到cost2 --- 产生环路

破环：
1.15跳的开销限制 -- 开销值不断叠加，自动破环
2.触发更新 -- 当拓扑结构发送变化的第一时间，将该变更信息传递出去
3.水平分割 -- 从哪个接口学习的信息，将不再从该接口发出
	#此时R1从R2收到的失效网段信息，此时将不再发送给R2该网段信息
4.毒性逆转 -- 从哪个接口学到的信息，依旧从这个接口发出，但是带毒传输
	#cost改为16，此时R1可以发送给R2失效网段的信息，但是cost必须为16
#在一台路由器上，水平分割和毒性逆转只能二选一，华为默认为水平分割
#如果同时开始水平分割和毒性逆转，则华为将按照毒性逆转执行
```

###### RIP配置

```shell
1.配置loop和接口
2.启动rip
3.选择版本
4.宣告 
	#要求：①所有直连都要进行宣告
	#	  ②必须按照主类进行宣告
	#目的：①激活接口 -- 只有激活接口才能接受发送RIP数据
	#	  ②发布路由 -- 只有激活接口对应网段信息才能被发布
#沉默接口 -- 将接口配置为沉默接口，则这个接口将只接受不发送RIP数据包
	#silent-interface G XX/XX/XX
RIPV1和RIPV2不兼容
	RIPV1的数据包
		command -- 表示RIP数据包类型 1.response 2.requset
		version -- 版本 V1 -- 1 V2 -- 2
		路由条目信息:  #一条RIP数据包信息最多包含25条路由信息
			Adderess Family -- 地址族标识符 (IP -- 2)
			Route tag -- 路由标签 -- 给流量打标签
			目标网段 + 子网掩码 + 开销值
			Next Hop 下一跳
#一般情况下，下一跳字段均为0.0.0.0,如果存在寻路不佳，则下一跳会携带最佳的下一跳地址
RIPv2的下一跳问题:应对选路不佳的情况下，可以指定下一跳而不是按照算法来算出下一跳
	
重发布：不同的路由协议的运行原理和对路由的理解不同，所以不同的路由协议之间存在信息隔离。而想让不同的协议的路由信息互通，可以在运行不同协议的边界路由器上，将不同的路由协议之间进行转换 -- 重发布 -- 路由器将一种协议通过另一种路由协议的方式传播出去
	#[r1-rip-1]import-route static
	
RIPV1和RIPV2的互通方法：
	1.重发布
	2.将RIPV1的边界接口上设置为[g0/0/0]rip version 2(反之亦然)

RIP的扩展配置：
	1.RIPV2的手工认证 
	#由于v2没有给认证预留空间，所以进行认证之后，认证数据会占用一条路由条目的空间，导致进行认证的RIP数据包中，最多只携带24条路由条目信息
	#rip authentication-mode simple cipher xxx   <密文密码>
	2.RIPV2的手工汇总 -- 一旦汇总，将抑制汇总前路由，将其开销设为16(带毒传输)
	#rip summary-address X.X.X.X 255.XXX.XXX.XXX	<掩码为完整版>
	#汇总后记得空接口！！！防环
	#汇总的优点：①减少路由条目数量，提高效率
	#		   ②可以防止路由表翻滚，确保网络稳定性 
	#			<汇总前如果分网段存在波动，此时会不断发送更新信息>
	3.加快收敛 -- 减少计时器时间
	#timers rip xx xx xx <更新 垃圾 回收> -- 修改时要保证计时器间的倍数关系
	4.缺省路由
	#defaule-route originate -- 在边界路由器上部署，使得边界路由器为缺省源，所有的内网设备将自动生成一条缺省路由指向边界方向(边界设备上的配置需要手工配置)
	#rip summary-address 0.0.0.0 0.0.0.0 
	#在边界路由器连接内网的接口上配置汇总信息
#交换机泛洪条件：1.广播帧，2.组播帧，3.未知单播
#RFC -- 行业技术汇编 其中的3171为针对RIP 
```

###### RIP的路由控制

```shell
RIP路由受优先级，cost影响
	修改路由优先级：preference  
		#仅影响本地路由表，仅适用于不同协议之间进行比较选路
	修改路由开销值 ：
		1.RIP中不允许将cost修改小，RIP路由范围有15跳限制，如果随意改小，15跳就形同虚设，所以只能将cost改大
		2.增加cost值： #配置在接口上{metricout出方向/metricin进方向}
			①修改路由出方向，路由信息发出的路由器上进行修改(不影响自身，只影响他人)
				#如果在出方向修改，则修改路由传递时的增加值<从+1变成+X，x>1>
			②路由入方向修改，路由信息接受方的路由器进行修改(只影响自身，不影响他人)
				#如果在入方向修改，则本地路由表开销值的基础上增加
		#如果需要进行精准控制，就是对某个网段的路由信息开销值进行调整，可以用ACL策略对该网段流量抓取，在针对抓取流量进行开销值修改
			A.出方向修改
			a.acl流量网段抓取
			#acl 2000 //基础acl抓取
			#rule permit source X.X.X.X 0  //抓取一个网段路由信息
			b.接口上设置开销值(出方向)
			#rip metricout 2000 10   //cost +10
			B.入方向修改
			a.acl抓取
			#acl 2000 
			#rule permit source X.X.X.X 0  
			b.接口上设置开销值(入方向)
			#rip metricin 2000 3    //cost +3+1
```

###### RIP的路由过滤

```shell
	路由过滤属于路由控制的一种，可以过滤掉某些路由信息，从一开始就不去加载到路由表(不学习该路由)
	路由过滤也分入方向(影响自己)和出方向(影响别人)
	#华为中，路由过滤需要使用过滤列表 -- filter policy
	#过滤列表属于高阶列表，但是本身不具备过滤功能，所以需要调用ACL列表，需要调用ACL列表，并且依赖ACL列表的过滤功能
	A.出方向修改
	①抓取acl列表
	#acl 2000 
	#rule deny source X.X.X.X 0
	#rule permit source any  //***一定要加***
	#华为ACL列表末尾并不是隐含了一条允许所有的规则，而是对未匹配的流量不做处理，如果不加这一条，则将会过滤掉所有路由信息
    ②通过过滤列表对路由信息进行过滤(rip内)
    #filter policy 2000 export G x/x/x   //路由出方向上调用过滤列表
    B.入方向修改
	①抓取acl列表
	#acl 2000 
	#rule deny source X.X.X.X 0
	#rule permit source any  	  //***一定要加***
	②通过过滤列表对路由信息进行过滤
	#filter policy 2000 import    //路由入方向上调用过滤列表
```

###### 单播邻居

```shell
	沉默接口只收不发，但是路由器下的PC会接受到RIP信息，所以使用单播邻居
	如果存在多个路由器，则各路由器之间需要互相设置单播邻居和沉默接口
	#peer  x.x.x.x  //单播邻居配置(邻居之间必须互相指定对方为自己的单播邻居)，但是组播和广播形式发送<所以单播邻居需要和沉默接口一起使用才能达到效果>
	沉默接口： 1.只收数据不发数据 2.沉默接口只影响组播和广播包，但对单播不影响
	#相当于在network宣告下,将接口宣告为peer
```

### 数据链路层的网络类型 

```SHELL
根据数据链路层所使用的协议及规则来进行划分
	1.P2P网络 --- 点到点网络
	2.MA网络 --- 多点接入网络
		①BMA -- 广播式多点接入网络
		②NBMA -- 非广播式多点接入网络
```

###### 数据链路层的网络协议

```shell
以太网协议 -- 封装数据帧时，需要如源MAC地址和目标MAC地址(MAC地址是以太网独有的)
	#利用以太网的二层网络中可以包含的多个接口(>=2),每个以太网接口之间都可以通过交互以太网帧的形式进行二层通讯(以太网组建多节点网络)--MAC地址用来区分主机
	#所以以太网属于MA网络，因为以太网支持广播，所以以太网属于BMA网络(广播)
	
	为什么以太网的速度比串线快 -- 以太网的频分技术(以太网的一根铜丝上可以同时发送不同频段的信号，且互不干扰。实现数据的并行发送)
#{同轴电缆[传递数字信号],电话线(RJ-11)[传递模拟信号],光纤[光信号]} --- 以太网技术

当一个网络中只能存在两台设备，并且不允许第三台设备(无论是什么设备，包括集线器等)加入，这样的网络称为P2P网络 -- 不需要MAC地址进行主机区分 <使用串线，且设备上有对应的串线端口 --- 串线网络>
	#串线[传输距离远且安全]
	#两种串线标准①T1：最大到1.544Mb ②E1：最大到2.048Mb
	
#display interface serial x/x/x   查看串线接口的二层特征
#link-protocol	xxx   进入串线接口，然后更换协议
在P2P网络中，如果对应的接口的串线协议不一样，则无法通信(封装方式不一样)，串线的通信标准为双up + ip address 
#没有ip也可以正常通讯，配置ip主要是为了ping地址，主要为了三层通讯(三层协议)
```

###### 串线协议(HDLC,PPP)

```shell
HDLC : 高级数据链路控制协议 -- 应用在串线的数据链路层协议  (缺点：兼容性不强)
	满足标准的HDLC ：ISO组织在SDLC的基础上优化得来
	非标准的HDLC ：各大厂商在标准的HDLC的基础上进行优化发展得来的
		#不同的厂商的HDLC和标准的HDLC有区别
		#<思科使用的是非标准的HDLC协议,华为使用PPP协议>
		#<如果华为切换为HDLC，也是非标准的HDLC协议>
		#有趣的是，非标准的HDLC协议被抓包都默认是思科的
	HDLC的数据包内：字段较少 -- 完成的事情较少
#没有MAC地址(P2P网络)，使用Portocol协议来标定上层协议[类似于以太网的type]，仅能完成介质访问控制工作

PPP :点到点协议 -- 应用在串线链路的协议
	1.PPP协议具有相同的标准，所以兼容性较强(同时也可以支持 任何一种支持全双工的串线之中)
	2.有较强的可移植性     PPPoE ---> PPP over E (E:以太网)  
		#PPP协议可以做认证和授权   --- 可以做计费系统
			#在计算机上的查看：<电脑-设置-网络-拨号-连接-设置新连接-PPPoE>

PPP和TCP协议一样，需要去建立相应的PPP会话，分为三个阶段：
#！！！PPP会话是一次会话，一旦建立成功，无论后续是否密码成功，都不影响 [产生验证,则需要shutdown对应接口，再重启]
#！！！设置认证则需要重新建立PPP连接 (到两边接口上进行shutdown，再undo shutdown)
1.链路建立阶段 --- LCP建立
	主要任务是通过LCP协议来建立链路时所需要的一些参数的协商工作
		协商内容： 1.MRU 2.第二阶段是否认证部分，还有如何进行认证
			①MRU(PPP帧的数据部分所携带的最大传输单元。类似于MTU)
			#MTU(以太网帧的数据部分所携带的最大传输单元)
			②发送是否认证 -- 回包：ACK(同意)/NAK(不同意)
			#串线双发互相发送，直到双方协商到互相发送ACK，此时结束第一阶段
2.认证阶段 --- PPP认证 (可选，非强制)
	PPP的认证阶段可以调用aaa来进行认证(aaa:认证，授权，计费)
	PPP的认证可以是单向认证也可以是双向认证(A-B:A要求B带认证，B发送认证信息，而A不需要)
	认证：①PAP -- 密码认证协议
			如果认证选择的是PAP协议，则被认证方将用户名和密码以*明文形式*发送给认证方
				被认证方发送Request包，认证方回复ACK/NAK -- 认证成功/失败
		 ②CHAP -- 挑战握手协议(安全性高于PAP，通过比对摘要值的方法来进行认证)
			a.认证方发送一个challeng包
				#challeng包[包含有用户名+一个随机数C]
			b.被认证方通过本地计算hash值A1，然后回复一个response包
				#response包[包含本地计算的hash值A1]
			c.认证方通过本地计算hash值A2，然后与A1进行比较
            	#比对成功则返回success/失败则返回failure
				#A1 = hash[C,之前共同协商的共享密码(被认证方的)]
				#A2 = hash[C,之前共同协商的共享密码(认证方的)]，然后比较A1和A2
3.网络层协议阶段 --- NCP协商 (NCP是一系列协议)
	以IPCP为例：IPCP协议去协商网络层的相关参数：①ip地址②ip报文的压缩格式
	①如果双方有ip，则双发互发送包来检验是否同意授权对方的ip地址
			#(通过ACK/NAK进行确定，request包进行请求)
	②如果，有一方没有ip地址，则可通过NCP协商机制，可以做到自动发送ip地址
		a.发送方发送request包(由于没有地址，只能携带0.0.0.0网段)
		b.接受方收到request包，此时查看本地路由，有一个空闲ip地址，然后回复NAK包
			(接受方发送的NAK包，携带空闲的ip地址)
		c.发送方获得接受方的ip地址，此时发送request包(包含接受包的ip)
		d.接受方同意该地址，回复ACK包
		
#摘要值A1,A2 - 通过hash算法来算出来的数据 
#hash - 散列函数：将任意长度的输入转化为固定长度输出 -- 固定长度(128)的输出就是摘要值
#hash算法不同于加密算法 -- hash不可逆，加密算法可以通过解密得出原值
#hash算法特点：①不可逆性 ②雪崩效应
#①不可逆性(无法转化回来) -- 压缩映射(映射为固定长度)
#②雪崩效应 -- 如果输入存在细微变化，则输出的摘要值将发生明显变化(哪怕多一个空格，hash的输出都有变化)
	
PPP协议中包含多个成员协议：
	①LCP协议 --- 链路控制协议
	②NCP协议(一堆协议的总称) --- 网络控制协议
		- IPCP协议(针对三层的IP协议时的协商)
    
PPP的帧结构：
	F A C 协议 信息部分 FCS F
F -- flag -- 相当于以太网帧中的前导符 (7E - 占位一个字节)   
	#[如果在PPP帧中如果存在其他的7E(非FLAG)则需要转意]
A -- address -- FF填充(链路层不需要ip,固定取值) - 占位一个字节
C -- control -- 03填充(用处不大,固定取值) - 占位一个字节
协议 -- 表明后续信息部分采用的协议类型 - 占位两个字节
# F A C 协议 为帧固定头部结构
FCS -- 帧校验序列 -- 进行数据完整性校验
F -- flag -- 相当于以太网帧中的前导符 (7E - 占位一个字节)   
#FCS F 为帧固定尾部结构
```

###### GER,MGRE

```HTML
NAT技术：只能转换源IP/目标IP的一个 (将其中一个设置为公网ip)
所以无法去用私网访问私网登录 -- (需要通过更改源IP/目标IP)

物理专线 --- 成本高，个人位置不确定
VPN --- 虚拟专用网，虚拟专线
VPN --- 核心技术(隧道技术) - GRE

GRE -- 通用路由封装 --- 创建一条点到点的隧道
	希望走法:
	SIP(本地私网出口) DIP(访问私网入口) 数据
	真实走法:
	SIP(本地私网出口) DIP(isp公网入口) 数据
	GRE技术:
	SIP(本地私网出口) DIP(isp公网入口) GRE SIP(本地私网出口) DIP(访问私网入口) 数据
隧道技术 -- 通过封装以及解封装技术在公网上上建立一条数据通道，使用这个数据通道，进行数据传输
一旦隧道建立成功后，将会把两边的私网融合成一个私网 所以，在一开始分配网段时，就需要考虑，避免网段冲突
```

![1641692739192](C:\Users\14202\AppData\Roaming\Typora\typora-user-images\1641692739192.png)

###### GRE问题与MGRE

```shell
GRE搭建的是一个点到点的隧道，所以导致其扩展性较差(当多个私网需要互相链接时，需要搭建多个GRE隧道)
此时需要使用MGRE技术(多点通用路由封装技术)
技术问题：此时Sip为私网1的ip，而Dip不固定(可能为私网2~4)
	NHRP协议：下一跳解析协议(自动学习隧道地址和物理地址的对应关系的一种方式)
		原理：需要在私网中选出一个不会变化的物理接口作为NHRP的中心(NHS - 下一跳服务器)，剩下的分支都需要知道中心的隧道IP和物理接口IP，他们需要将自己的物理接口IP和隧道IP发送给中心(如果分支的物理接口的IP地址发生变化，则需要立即将对应关系重新发送)。主要NHS讲会收集到所有分支的地址映射关系。之后需要通讯时，查看对应关系，封装对应的接口IP即可分支之间需要进行通讯，则先将数据发给中心，由中心进行转发.
		这种中心站点到分支站点的架构 -- HUB-SPOKE架构
		因为MGRE搭建的逻辑拓扑是一个多节点的网络，但是发送信息时依然是点到点的发送，无法使用广播/组播行为，这样的网络可以称为NBMA网络(属于逻辑上搭建的NBMA网络，真正意义上物理设备搭建出的NBMA网络是帧中继。）
		
MGRE的配置过程：
给中心站点进行配置:边界路由器出接口的公网ip地址不会发生变化作为NHS(中心站点)
	#中心做法:创建隧道接口 -- 配置隧道ip地址 -- 选择封装类型(MGRE:GRE P2PM) -- 定义源ip地址(固定) -- 创建NHRP域
		#NHRP域为全局唯一的(不同于RIP的域)
		#display nhrp peer all  -- 查看NHRP表的配置情况
给分支站点进行配置:
	#分支做法:创建隧道接口 -- 配置隧道ip地址 -- 选择封装类型(MGRE:GRE P2MP) -- 以接口作为封装源(以应对ip地址的变化) -- 加入到NHRP域(必须是和中心站点创建相同的域) -- 找中心站点进行注册(nhrp entry 隧道地址[本地] 物理接口地址[本地] register)
	#然后再写条静态！！！ 目的:记录到路由表上

通过RIP获取路由信息:
	1.中心站点可以收到分支的数据包，但是分支不能收到中心站点的数据包(MGRE不支持广播/组播行为 -- 在中心站点开启伪广播)
		#伪广播:给所以节点发送单播充当广播作用 --- 此时分节点只有中心的路由RIP信息
		#在管道上 nhrp entry multicast dynamic
	2.开启伪广播后，分支站点只能收到中心站点的路由信息，却不能收到其他分支站点的路由信息  -- RIP水平分割导致的(从哪个接口学的，将不再从该接口学习)
		#undo rip splite-hirizon -- 关闭接口水平分割
```

### OSPF协议

```shell
动态路由(IGP)的评判标准:选路佳，收敛快，占用资源少
	RIP[距离矢量协议]:选路以跳数为开销值(不够智能，有出环的问题);收敛速度以计时器为标准(较慢);单个数据包占用少[但是有一个30s的更新包<占用大>]
	OSPF[链路状态协议]:选路以带宽为标准(SPF算法-树形结构不出环);收敛快(较快);单个数据包占用大[40s的hello包<占用少>]
	
RIP存在三个版本 -- [RIPV1,RIPV2 -- IPV4],RIPNG -- IPV6
OSPF的三个版本 -- OSPFV1(淘汰),OSPFV2 -- IPV4,OSPFV3 -- IPV6

RIPV2和OSPFV2区别:
	相同点: 
	1.RIPV2和OSPFV2都是无类别的路由协议{传递[路由信息]时携带子网掩码}，都支持子网划分和子网聚合
	2.OSPFV2(224.0.0.5/224.0.0.6)和RIPV2(224.0.0.9)以组播形式传递信息
	3.OSPFV2和RIPV2都支持等开销负载均衡
	不同点：
	OSPF和RIP不同，RIP要求仅适用于中小型网络环境中，OSPF可以适用于中大型的网络环境中
	#OSPF为了适应中大型网络环境，需要进行结构化部署 --- 区域划分
```

###### OSPF - 开放式最短路径优先协议

```shell
OSPF为了适应中大型网络环境，需要进行结构化部署 --- 区域划分
当网络规模不大时，我们也可以将OSPF网络划分在一个区域内，主要的OSPF网络 -- 单区域网络
如果一个OSPF网络中包含有多个OSPF区域 --- 多区域OSPF网络
区域划分的主要目的 -- 区域内部传递拓扑信息，区域之间传递路由
#(链路状态路由协议的距离矢量特征:区域间传递路由)
区域边界路由器 --- ABR 
#同时处于多个区域，且一个接口对应一个区域，至少有一个接口属于骨干区域，区域之间可以存着多个ABR，一个ABR也可以对应多个区域
区域划分的要求: 
1.区域之间必须存在ABR
2区域划分必须按照星型拓扑结构划分 -- 所有区域需要连接在中心区域上(中心称之为骨干区域)
为了方便对各个区域进行区分和管理，我们给每个区域设计一个编号 -- 区域ID
#由32位二进制表示，也可以用点分十进制表示，或者直接用十进制来表示，且骨干区域必须为0
```

###### OSPF的数据包

```shell
hello包:
	①用来周期发现，建立和保活邻居关系(周期为10s/30s)
	②死亡时间:dead time(4倍hello时间--40s/120s)
	③hello包会中携带RID
#因为OSPF传递的是拓扑信息，需要将所有的路由器的位置关系表示清楚，所以需要有一个参数对所有的路由器进行区分表定 -- 引入RID来完成
#RID需要满足条件:1.唯一性(OSPF网络区域内部唯一) 2.格式统一(又32位二进制构成，采用IP地址的格式)
#RID的获取方式:1.手工配置(需满足两个要求) 2.自动获取(如果是自动获取，设备将在自己的环回接口的ip中选择最大作为自己的RID)
DBD包:
	数据库描述报文，携带的是数据库目录信息(LSDB:存放LSA信息的数据库)
LSR包:#request
	链路状态请求报文，基于DBD包请求未知的LSA信息(本地所没有的LSA信息)
LSU包:#update
	链路状态更新包，真正携带LSA信息的包(真正的有链路信息的包)
LACK包:#ACK
	链路状态确认报文(确认包)

#OSPF因为有hello包和LACK包，所以有保活和确认机制 ---> 所以不需要进行周期更新
#但是OSPF存在每30Min一次的周期更新(再次确保更新可靠)
```

###### OSPF的状态机

```shell
①Down State(关闭状态):启动OSPF后，发送hello包包含RID，进入下一个状态
②Init State(初始化状态):收到对方hello包中包含RID，进入下一个状态
③Two-Way State(双向通讯状态):标志邻居关系建立
[条件匹配]  --- 成功则进入下一个状态，否则只能停留在邻居关系
	#邻居关系只能通过hello包进行包活
④Exstart State(预启动状态):使用未携带数据的DBD包进行主从关系选举 
#主从关系选举，通过比较未携带数据的DBD包中的RID大小进行主从关系选举，RID大的为主，优先进入下一个状态  ###使用未携带数据的DBD包原因 -- 和邻居状态进行区分 
#RID比较只是单纯的比较数值大小,与子网掩码无关
#{此时只是互相比较RID信息,而没有通过ACK来确认 --- 隐形确认}
⑤Exchange State(准交换状态):使用携带数据的DBD包进行数据库目录信息进行共享
#主从关系的原因:错峰发送链路信息，降低带宽阻塞
⑥Loading State(加载状态):加载对端的DBD包中的信息和本地的LSDB数据库目录信息进行对比
#基于位置的LSA信息，发送LSR包，对端回复LSU包，需要LACK包进行确认
⑦FULL State: 标志着邻接关系确认
#领接关系主要是为了和之前的邻居关系进行区分
```

###### OSPF工作过程

```shell
	启动配置完成后，OSPF向本地所以允许OSPF协议的接口以组播224.0.0.5发送hello包，hello包中携带本地的RID以及本地已知邻居的RID。之后将收集到的邻居关系记录到本地表上{邻居表}
	#邻居表建立之后，进行条件匹配。失败则停留在邻居关系(仅能使用hello包进行周期保活)/成功则开始建立邻接关系。
	邻接关系建立后，首先使用未携带数据的DBD包进行主从关系选举。之后使用携带数据的DBD包进行数据库目录的共享。之后本地使用LSR/LSU/LACK包来获取未知的LSA信息，完成本地数据库建立LSDB(链路状态数据库) ---生成{数据库表}
	最后，基于本地的链路状态数据库，生成有向图。之后，通过SPF算法将有向图转化为生成树，并计算本地到达未知网段的路由信息，将路由信息添加到路由表中{路由表}
	收敛完成后，hello包依旧需要10s(30s)进行一次周期保活和每30min进行一次周期更新
```

```shell
网络结构突变 
1.新增一个网段:触发更新，直接通过发送LSU包将变更信息发送，需要等待等待LACK确认
2.断开一个网段:触发更新，直接通过发送LSU包将变更信息发送，需要等待等待LACK确认
3.无法沟通: hello包+死亡倒计时(10s+40s/30s+120s)
```

###### OSPF的基本配置

```shell
1.启动OSPF进程
	[R1]ospf 1 router-id X.X.X.X   #X.X.X.X 进程号，仅有本地意义(手工配置RID)
2.版本选择(V1淘汰，默认为V2)
	[R1]ospf
3.创建区域(在版本选择后)
	area X
4.宣告
	①激活接口:只有激活的接口才能收发OSPF数据 
	②发布路由:只有激活接口对应网段信息才能发送
	network X.X.X.X  x.x.x.x   配置符为反掩码
		#反掩码使用连续的0和连续1组成:0不可变，1可变
		#通配符与反掩码不一样，通配符使用不连续的0和1组成:0可变，1不可变
		#通配符0.255.0.255 --- 可变.不可变.可变.不可变
#查看ospf邻居表:display ospf peer
#查看ospf邻居简表:display ospf peer brief
#查看ospf数据库表[目录]:display ospf lsdb
#展开一条LSA信息:display ospf lsdb router X.X.X.X
#查看ospf路由表:display ospf protocol ospf
#华为设备给OSPF定义的默认优先级为10,华为设备OSPF的默认参考带宽为100Mbps
#OSPF是以带宽作为开销值:COST = 参考带宽/真实带宽
#OSPF开销值为小数时:当该数为大于1的小数，则直接舍弃小数部分取整;如果是小于1的小数，则直接设置为1
#bandwidth-reference X  修改OSPF带宽
#如果参考带宽修改，则所有设备上都要进行修改！！！
```

OSPF的优先级

```

```

OSPF数据包

```shell
	OSPF协议是跨层封装的协议,跨四层封装,直接将应用层的数据封装在网络层协议后面的.IP协议包中协议号字段为89
OSPF的头部数据(OSPF数据包都有的相同数据)
	版本:OSPF版本,IPV4使用OSPFV2，版本号为2
	类型:OSPF的数据包类型{hello-1,DBD-2,LSR-3,LSU-4,LACK-5}
	RID:谁发的数据包,就写谁的RID
	AREA ID:数据包从哪个区域发出的,就写哪个区域ID
	OSPF的认证
#OSPF的认证类型:{null(不认证)-0,simple(明文认证)-1,MD5(通过比对摘要值进行认证)-2}
#	OSPF在进行认证时,需要比较两部分数据:一部分为认证类型,一部分为认证数据

hello包:
1.网络掩码:接口一旦激活就会发送hello包,这个接口本身配置的IP地址的掩码信息
#华为设备要求,邻居之间hello包携带的子网掩码必须相同,不同则无法建立邻居关系
#只针对以太网接口进行检测,对P2P网络不做限制
2.hello时间和死亡时间:邻居之间所携带的hello和死亡时间必须相同.不同则无法建立邻居关系
3.8位可选项:每一个比特都表示路由器携带的某种OSPF特性
#每8位特殊标记包含OSPF特殊区域的标记,这个特殊区域的标记在邻居关系建立中也需要检测
#如果特殊区域标记不同,则也无法建立邻居关系
			#特殊区域后面讲
4.路由优先级:指的是发出接口的DR/BDR选举的优先级
5.指定路由器/备份指定路由器:在DR/BDR选举完成后,将会把DR/BDR的IP信息携带在该字段.
#在DR/BDR未选出之前,将以0.0.0.0来填充
6.邻居:指的是本地已知的邻居的RID,这个是邻居关系建立的重要标志

hello包对邻居关系建立的限制条目:		#(如果有一点双方没有配对成功,则无法建立邻居关系)
1.网络掩码(只针对以太网口)
2.hello时间
3.dead time
4.OSPF特殊区域标记
5.认证  (密码)

DBD包:
	#主从关系选举作用:1.为主的可以优先进行LSA交换 2.主可以决定隐性确认包的主导
		#一开始双方的DBD的都会携带一个随机的DD值,在决定主从以后会使用主的DD值
1.接口最大传输单元(MTU)
	#华为设备默认不检测,一般携带值为0.可以在接口上开启检测功。开启后,数据包将携带真实的MTU值。在exstart状态下交互DBD包,如果邻居的MTU值不一致,则将停留在exstart状态
2.8位可选项:(每一个比特都表示路由器所携带的某种OSPF的特征)
	I - INIT:该位置置1,则代表此时的DBD包是进行主从关系选举的DBD包,后面不携带LSB摘要信息
	M - More:该位置置1,则代表后续还有更多的DBD包,该位置0,则代表这个DBD包是最后一个DBD包
	MS - Master:该位置置1,则代表发送DBD包的设备为主,置0则代表该数据包设备为从
	#在主从关系没有选举出来之前,邻居双方会将自己的MS置1,认为自己为主.再比较
3.DD序列号:在DBD报文交互过程中,会逐次+1,,用于DBD报文传输的有序性和可靠性
#DBD包的确认机制的通过序列号来实现的隐形确认.而通过ACK数据包来实现确认的方法为显性确认
#隐性确认机制:主设备发送一个DBD包,其中包含一个DD序列号,从回复的DBD包的DD序列号为主刚才发送的DD序列号,做到确认的作用    ###最后主更新完数据后,会发送一个DBD包进行确认收到信息

LSA头部信息 -- 并不是一个完整的LSA信息,相当于LSA信息的一个摘要 #伏笔

LSR包:(基于DBD包中的摘要信息,和本地LSDB进行比对,之后请求未知的LSA信息)
#链路状态类型,链路状态ID,通告路由器 -- LSA的(三元组)三个重要组成:可以唯一标识出一条LSA

LSU包:(真正携带LSA信息的数据包)
#携带LSA个数和LSA

LSAck:链路状态确认报文
#通过携带LSA头部信息来确认

#BR/BDR和主从选举不是同一个概念！！！ 
	#BR/BDR
```

###### OSPF的接口网络类型

```shell
P2P/MA(BMA/NBMA)  
	#OSPF的接口网络类型 - 实际上指的是OSPF接口在不同网络环境下默认的不同工作模式

网络类型				OSPF接口的网络类型(工作方式)
BMA(以太网-广播式)	  [Broadcast]  需要DR/BDR选举(hello 10s,dead time 40s)
P2P(PPP/HDLC/MGRE)	  [P2P]  只能建立一个邻居关系,不需要DR/BDR选举(hello 10s,dead time 40s)
环回接口(虚拟接口)	 	 [P2P]  华为设备标记为P2P类似,但实际无数据收发(学习到/32的主机路由)
P2MP(人造的,不存在)	  [没有正式的网络环境!!!]   可以创建多个邻居关系,不需要进行DR/BDR选举(hello时间为30s ，dead time 120s)，可以学到邻居接口的主机路由
NBMA(帧中继)			[NBMA]  不会主动建立邻居关系,需要手工指定.需要进行DR/BDR选举(hello时间为30s ，dead time 120s) #NBMA建立邻居关系的方式 - 手动指定,使用单播邻居
#P2MP是改进NBMA的版本

华为设备的接口遵循的是E1标准,最大的传输速率为2.048Mbps
华为设备环回接口的开销值默认为0,这个值不受外界干扰(修改参考带宽不会影响环回接口的开销)
华为设备将管道接口的传输速率定义为64Kbp(实际上改接口为虚拟接口,不存在传速率,传输速率取决于物理接口) -- 目的为了避免选路时选择管道接口,因为走隧道接口需要复杂封装,消耗真实线路的带宽

#在NBMA网络中会存在一个attempt状态(过渡状态,当双方均指定对端为邻居后,将会进入下一个状态init)
```



###### OSPF的不规则区域

```shell
OSPF区域划分的要求:
	1.区域之间的存在ABR
	2.区域划分必须按照星型拓扑结构来划分
OSPF不规则区域划分:
	1.远离骨干的非骨干区域
	2.不连续骨干区域
#远离骨干的非骨干区域:会产生非法ABR会导致无法进行区域共享(骨干无法和非骨干共享)
```

###### 远离骨干的非骨干区域

```shell
解决方式:
1.使用GRE隧道(在非法的ABR上搭建一个到达骨干的隧道,相当于直接把非法ABR连接在骨干区域,之后将接口在骨干接口在骨干区域进行激活,将非法ABR变成合法ABR，可以进行正常的路由转发，实现不规则区域通信) 
#注意:
#1.当一台ABR同时连接骨干和多个非骨干区域时,非骨干区域之间将直接通过这个ABR来传递路由信息,而不需要通过骨干区域
#2.当同时从骨干和非骨干区域学到路由信息,设备将无条件选择骨干区域发来的信息,而不是非骨干区域,哪怕开销巨大
	缺点: 
	①.OSPF会优先选择骨干区域学来的路由信息会存在选路不佳的情况
	②.资源浪费:非法ABR合法后,会同时从骨干(area 0)和非骨干(area 1)收到路由信息,导致信息的重复更新
	③.因为虚拟链路存在,R2和R4之间需要建立邻居关系,导致邻居之间周期性数据都需要穿越(area 1)传递,对(AREA 1)产生资源额外损耗
2.虚链路 (虚链路的邻居关系不会显示在邻居表,且虚链路永远属于区域0)
	配置要求:虚链路配置在需要穿越的区域内配置(比如同时配置在区域1)   
	#vlink-peer X.X.X.X 为跨越要区域建立虚链路的邻居RID,并且是双向的
	缺点:
	①.因为虚拟链路存在,R2和R4之间需要建立邻居关系,导致邻居之间周期性数据都需要穿越(area 1)传递,对(AREA 1)产生资源额外损耗
	②.虚链路只能穿越一个区域
3.多进程双向重发布(进程之间不能互相通信)
	在重发布配置在运行不同协议的路由器上,这样的路由器称为ASBR(自治系统边界路由器)
	#非法ABR运行重发布时只是在本地的ASBR上进行两个OSPF进程,相当于用进程1运行非骨干,而进程2运行原理骨干的非骨干
	#必须要运行了重发布的设备是ASBR,重发布后路由协议变为O_ASE,优先级为150(信任度低)
	缺点:重发布的路由为域外路由,可控性差(信任较低)
```

###### OSPF的LSA①头部信息

```shell
LSA:链路状态通告.OSPF协议在不同不同网络环境下携带和传递的信息
LSDB:链路状态数据数据库  --- LSA信息数据库
SPF:最短路径优先算法

LSA头部内容:
1.TYPE -- 描述LSA的类型(在OSPFv2中,需要掌握6种状态类型) 
2.LinkState ID -- 链路状态标识符.作用是用来标记一条LSA名字
	#不同类型的LSA获取的LinkStateID方式并不相同,可能会产生LSID想同的情况 -- LSID不能成为唯一标识
3.AdvRouter -- 通告路由器.标识发送该LSA信息的路由RID
	#LSA的类型,链路状态标识符,通告路由器为LSA的“三元组”  --- 可以唯一标识LSA信息
4.LS age -- 老化时间(单位:s).从诞生LSA就开始计时(而不是加入LSDB中开始计时),哪怕LSA在网络传播过程中老化时间仍会继续计时。直至到达1800s(30min存在一次周期更新),规定最大老化时间为3600s(MAX AGE)!!!OSPF域内的相同的LSA信息是同步的
	#当一条LSA老化时间到达3600s时,则该LSA信息将会失效,并直接删除
	#老化时间的刷新:周期更新;触发更新
5.Len -- 长度(LSA信息字节数)
6.Options -- 可选项(8个标记位)包括OSPF特殊区域的标识
7.Seq -- 序列号.每一条LSA都会携带一个序列号,用来区分LSA的新旧(每台路由器在发送相同的LSA信息是,都会携带一个序列号,并且该序列号逐次+1) -- 使用32位二进制表示
	#序列号空间的分类:
		#直线型序列号空间:
			#优点:方便比较新旧,通过大小关系直接比较
			#缺点:序列号空间有限,如果到极限则无法判断序列号的新旧
		#循环性序列号空间:
			#优点:序列号可以循环使用,不受空间大小的限制
			#缺点:当两个LSA携带的序列号数值相差较大时,仍无法判断新旧
		#棒棒糖型序列号空间:	结合了直线性和循环性 - 但是本质上仍是直线型序列空间,为了避免循环部分造成新旧无法判断的情况,所以OSPF序列号不能进入循环,即OSPF的取值范围从0X-80000001到 0X-7FFFFFFF.
		#如果当LSA序号达到最大值7FFFFFFF时,则会发送一个seq置为7FFFFFFF,age置为3600的LSA信息,此时邻居会将这个LSA刷新到LSDB中(SEQ最大),并将其删除(AGE为3600s).此时将会从80000001重新开始发送新的序列号,再次发送一条相同的LSA信息给邻居,这条LSA信息序列号为80000001,此时邻居会将最新的LSA信息刷新到LSDB数据库中,以达到更新序列号空间作业
8.Chksum -- 校验核:主要是效验数据的完整性,这个效验核也会参与LSA的新旧比较
	#当存在两个相同的LSA且序列号也相同,则会通过校验核计算出来的数值最大的作为最新的LSA信息
```

###### OSPF的周期更新

```shell
OSPF的周期更新是1800s,可是会存在多次临近时间的同时更新 -- 占用链路资源,此时将周期更新的机制优化 -- 组步调计时器(300s)
当有LSA到达1800s,会等待300s然后将LSDB中老化时间为1800s-2100s的LSA信息更新
如果还有到达1800的则再次等待300s   --- 异步更新
```

###### 具体的LSA的信息②(除去头部信息)

**六种类型的LSA**

```shell
TYPE1-LSA:Router	OSPF网络内所有路由器都需要发送且只发送一条
	LINK:每一条LINK都是用来描述路由器接口的连接情况(一个接口有多个Link接口)
		Link-type类型:P2P,TransNet(BMA),StubNet(终端),Virtual(虚链路)
		#链接类型:主要和接口连接的网络类型有关,会根据具体接口的封装判断接口连接在什么网络上
	COST:接口开销值
TYPE2-LSA:Network	对MA网络的描述中,仅依靠TYPE1LSA无法获得具体说明,需要TYPE2LSA来补充		
		#二类TYPE2-LSA携带的公共部分信息,所以一个MA网络中只需要一个LSA即可,并要求这个MA网络中的DR发送以避免信息浪费,重复更新!!!
		
##################################一类和二类为拓扑信息#########################
	OSPF规定,所有传递路由的LSA信息必须经过拓扑信息(1类和2类LSA)验算 --- 通过拓扑信息找到路由信息的通告者(下一跳)

TYPE3-LSA:Sumary (跨区域的TYPE3，ABR的两个区域到达同一网段的LSA不一样)
	传递域间路由信息,通告者为域间的ABR,LSID为通告路由的网络好,本身携带的信息为两个:目标网段的子网掩码;通告者到达该网段的开销值。每一条路由信息都要发送一条
	掩码号:相当于描述需要从通告路由来到达目标网段(携带掩码)
	开销值:该通告路由到达目标网段的开销值+本地路由到通告路由的开销值

TYPE4-LSA:Asbr(作用:通告ASBR的信息,帮助ASBR以外区域对ASBR位置进行验算)
	#ASBR所在区域是不需要type4的LSA,因为可以通过1类和2类进行验算
	携带Ls ID,AdvRouter.除去ASBR所在区域,其他的OSPF单区域内会存在type4的LSA:ABSR,而ASBR的LSID标识ASBR,Adv为标识到达这个ASBR域的ABR设备

TYPE5-LSA:Exteranl	(和type3不一样,TYPE5使用的是ASBR而TYPE3使用的为ABR)
	主要传递的是域外路由信息,通告者是ASBR(自治系统边界路由器)。域外导入的TYPE5-LSA生成的路由信息在OSPF路由表中为O_ASE,优先级默认为150.携带开销值,E type,转发地址,Tag
	#重发布导入其他协议的路由信息,而不同协议的之间开销值标准是不一样的,所以在进行重发布导入后,并不能直接使用之前网络的开销值(RIP最大就15).此时在重发布导入信息后,需要赋予该路由信息赋予一个初始的度量值(seed-metric 种子度量值),而华为的SOPF网络中默认种子度量值为1 (在进行重发布导入时,可以对默认种子开销值进行修改imoprot-route rip 1 cost X)
	E type:这个E位标记位代表的是使用的度量值类型.默认情况下,使用类型2
	#在进行重发布导入时,可以对E type进行修改imoprot-route rip 1 type X   
		type为1时(E位置0时,使用类型1):如果度量值类型为类型2,则域内所有设备到达目标网段的开销值等于本地到达ASBR的开销值 + 种子度量值
		type为2时(E位置1时,使用类型2):如果度量值类型为类型2,则域内所有设备到达目标网段的开销值为种子开销值
	转发地址:主要目的是应对选路不佳的情况(TYPE5-LSA在不存在选路不佳的情况下,选路地址默认为0.0.0.0)
	Tag:路由标记(方便对流量进行标记,之后对标记的流量进行抓取和控制)
	
TYPE7-LSA:NSSA内传递
	7类LSA在NSSA内的路由信息为: 0.0.0.0 o_NSSA 150
    7类LSA是在NSSA由5类LSA转化而来的,而7类LSA再次转化为5类LSA(发送给骨干链路)时,转发地址会修改
	#7类LSA在默认存在选路不佳情况时,将携带ASBR环回接口的最大IP地址
		#如果不存在环回接口,将使用物理接口的IP地址作为转发地址
		#意思就是用ASBR路由器上一个存在的接口标定这个域外信息的接口,然后骨干区域用这个接口去访问域外信息(而不是直接去访问ASBR路由器,然后再让ASBR去访问域外信息)
		

##################################三类和六类为路由信息#########################
```

| TYPE             | LS ID                | 通告路由                                                     | 传播范围                     | 携带信息                 |
| ---------------- | -------------------- | ------------------------------------------------------------ | ---------------------------- | ------------------------ |
| TYPE1 --- Router | 通告路由器的RID      | 本区域内所有运行OSPF的RID                                    | 单区域                       | 本地接口直连拓扑信息     |
| TYPE2 -- Network | DR接口的IP地址       | 单个MA网络中的DR所在路由器的RID                              | 单区域                       | 单个MA网络的拓扑信息补充 |
| TYPE3 --Sum-Net  | 路由的目标网段信息   | 相邻区域的边界路由器ABR,如果要通过下一个ABR设备时则需要修改为新的ABR | ABR相邻单区域                | 域间路由                 |
| TYPE4--Asbr      | ASBR的RID            | 和ASBR同区域的ABR，在通过下一个ABR设备时,需要修改为新的ABR   | 除ASBR所在区域外的OSPF单区域 | ASBR的位置信息           |
| TYPE5 --exteranl | 域外路由的目标网络好 | ASBR                                                         | 整个OSPF域内传播             | 域外路由信息             |
| TYPE7 --NSSA     | 域外路由的目标网络好 | ASBR                                                         | 单个NSSA区域                 | 域外路由信息             |

###### OSPF的优化

```shell
实质是为了减少LSA的更新量
	1.汇总:减少骨干区域学习到的路由信息
	2.设置特殊区域:减少非骨干区域的LSA信息

汇总:
OSPF的汇总实质上是区域汇总,而区域汇总的实质是对传递路由信息的LSA进行汇总
	区域路由汇总:域间指的是区域间,在ABR上将区域间传递的3类type的LSA进行汇总
	#abr-summary X.X.X.X x.x.x.x  汇总后的网段  只能在ABR设备上生效
	#注意:ABR上进行的区域汇总一直是针对自己通过1类2类LSA路由进行汇总操作
	
	域外路由汇总:在ASBR上,通过重发布导入5类/7类LSA进入OSPF域中时,进行汇总
	#asbr-summary X.X.X.X x.x.x.x 汇总后的网段  只能在ASBR设备上生效
	#域外汇总网段LSA中的开销值:
		#类型1:如果开销值类型为类型1,则汇总网段的开销值等于明细路由的最大开销值(种子度量值)
		#类型2:如果开销值类型为类型2,则汇总网段的开销值等于明细路由的最大开销值+x(默认为1)
		#asbr-summary X.X.X.X x.x.x.x  cost X  可以修改网段的开销值(需要为类型2) 

特殊区域:一共存在四种特殊区域,分为两大类,而每一大类再细分为两小类
第一大类
①特殊区域(stub):末梢区域
	要求: 1.不能是骨干区域 2.区域中不能存在虚链路(跨区域) 3.区域中不能存在ASBR(不能重发布)
	#管道区域可以(类似于只能单挂在骨干区域下) ,满足要求的区域可以被配置为末梢区域(STUB)
	#如果将一个区域配置为末梢区域后,这个区域将不再接受4类和5类LSA(相当于不接受域外信息)
	而为了保证末梢区域正常访问到域外的路由,所以必须有缺省路由指向骨干区域.
	当设置完末梢区域后,将自动生成一个指向骨干的三类缺省(stub -- 在末梢区域上配置,此时为末梢区域)
	#注意此时也要在ABR上对应的area配置stub -- hello上特殊区域要对应匹配,否则无法建立邻居关系
	配置为末梢区域后,末梢区域内只会保存1.2.3类的LSA在LSBD表上
②特殊区域(Totally stub):完全末梢区域
	在末梢区域的基础上进一步拒绝学习3类LSA(仅保留3类的缺省路由)
	#stub no-summary 只需要在ABR上设置,无需在stub区域内配置
	此时完全末梢区域内的ospf路由表只有一条缺省路由.
	完全末梢区域内的LSDB数据库表只有一条缺省路由和本区域内的1类和2类LSA信息
第二大类:
①特殊区域(NSSA):
	要求: 1.不能是骨干区域 2.区域中不能存在虚链路(跨区域) 3.区域中存在ASBR(重发布)
	#满足要求的区域可以配置为非完全末梢区域(NSSA)
#注意此时也要在ASBR上对应的area配置nssa -- hello上特殊区域要对应匹配,否则无法建立邻居关系
#配置完末梢区域后,末梢区域内只会保存1.2.3类的LSA
	#如果将一个区域配置为非完全末梢区域后,这个区域将不再接受4类和5类LSA(相当于不接受域外信息).此时引入7类LSA(相当于4类和5类的重命名),在NSSA去内,5类LSA被转化为7类LSA,7类LSA只能在NSSA内传播,而连接骨干区域的ABR相当于变成了ASBR,转化7类为5类(省去4类LSA)发送到骨干区域.
	#【相当于NSSA成为一个防火墙,只会接受本地区域内的域外信息(此时用7类LSA表示),而因为不能接受4类和5类LSA信息,会去拒绝骨干发来的其他ABSR的域外信息】
①特殊区域(Totally NSSA):完全NSSA区域,在NSSA区域的基础上进一步拒绝学习3类LSA
	#nssa no-summary 只需要在ASBR上设置,无需在stub区域内配置
	#此时NSSA的LSDB表上只会有1.2.7类LSA(NSSA还需要通过7类LSA来传递域外信息)
	#但是其中会有两个缺省路由到骨干链路(一个为3类缺省,一个为7类缺省)
    #但是因为3类LSA的优先级高于7类LSA,所以在NSSA的路由表上选择3类缺省加入OSPF路由表上
	
总结:在配置特殊区域时,一定要注意缺省方向.自动生成的缺省必须要和手动设置的缺省方向一致	
	如果OSPF区域想要去访问ISP,默认需要将ISP设置在骨干区域内.原因:其他区域会有缺省到达骨干区域(需要注意手动设置的缺省和特殊特殊区域的缺省方向)
```

###### OSPF中的特殊标记位:

```shell
E位:一般置1,代表支持5类LSA(置0,表示为特殊区域)
N位:一般置0,只有在NSSA区域中置1,代表支持7类LSA
P位:如果置1,则代表该LSA信息支持7类转化为5类
```

###### OSPF的拓展配置：

```shell
1.手工认证:在OSPF数据包交互中,邻居之间的数据包中携带认证口令,只有两边认证口令相同,则代表身份合法
	OSFP的手工认证的三种方式:
		①接口认证:要认证比对的数据:认证类型,认证数据(keyid,口令数据)
			在接口上进行认证配置
		②区域认证:本质上还是接口认证,相当于将整个区域所有激活的接口都配置
			在区域上进行认证配置(相当于直接配置了区域内所有接口的认证方式)
		③虚链路认证:在建立虚链路的过程中进行的认证,本质上还是接口认证

2.加快收敛(修改OSPF计时器)
	如果hello时间修改,dead时间会自动按照4倍hello时间匹配修改
	如果dead时间修改,hello时间并不会自动匹配修改
	#如果邻居之间hello时间和dead时间不相同,则无法建立邻居关系
	OSPF还有一个waiting time:等待计时器(跟死亡时间长短一样,但是不显示)
	POLL:轮询时间(120s).和状态为down的邻居发送hello包的周期时间 
	#POLL只存在在NBMA网络中,NBMA网络中需要指定邻居关系
	#NBMA默认的hello包为30s(在waiting时间),如果waiting时间超过了则每120s发送hello包
	Retransmit:重传时间(5s)当设备发送数据报需要确认时,对方在重传时间内没有回复确认包,则会重新发送数据
	Transmit Delay:传输延迟(1s)。本地LSDB发送LSA信息时,需要从本地数据库中找出这条LSA信息,然后打包发送给对端的LSDB(补偿在传输过程中的损耗时间,所以在打包过程中默认加上延迟的时间)
3.沉默接口:主要用于连接用户的接口,使这些接口只接受不发送OSPF的数据
#OSPF的沉默接口会对单播包和组播包生效,不能和RIP一样结合单播邻居一样应用在一些特殊场景
4.缺省路由
	OSPF中的缺省路由总共可以分为三类:
	①三类缺省:无法手工产生,只能在特殊区域中自动产生
		普通stub区域，完全stub区域和完全nssa区域会产生三类缺省
		特点:类型为OSPF 优先级默认:10
	②五类缺省:可以通过命令可以手工配置,实际是将本地路由表中其他协议产生的缺省路由重发布到OSPF网络中.通过五类LSA携带
		#defaulat-route-advertise   需要本地路由存在有一条缺省路由
		特点:类型为O_ASE,默认优先级为150
		#如果本地路由表中没有其他协议产生的缺省路由,可以通过增加always进行强制下发
	③七类缺省:可以通过特殊区域自动生成/配置手工命令进行配置获取
		#七类缺省特点:类型为O_NSSA,默认优先级为150
5.路由过滤
	OSPF可以直接针对3类,5类,7类LSA进行过滤
6.路由控制:
	①优先级:只影响本地路由表的路由条目优先级
	②开销值:开销值=参考带宽/真实带宽
		#a.通过修改参考带宽来修改开销值(参考带宽一旦修改,所有的接口都会变好,并且要求网络中所有设备的参考带宽都修改成一样的.虽然可以影响开销值,但是并不适合影响选路)
		#b.通过修改真实带宽,影响接口开销值(可以修改真实带宽)
		以上两个方法不能直接影响环回接口的开销值
		#c.直接修改接口的开销值(也可以直接修改环回接口的开销值)
		OSPF开销值的结算方式是按照流量流入接口的开销来计算.所以在修改链接环路时,两边都要修改
```

###### OSPF的选路原则

```shell
域内:1类和2类LSA
域间:3类LSA
域外:5类,7类LSA (根据开销值的计算规则不同,还分类型1和类型2)

	1.如果学到的路由是通过1类,2类LSA获取的域内路由:直接比较开销值.优先选择开销值小的路由,如果两条路由的开销值相同,则负载均衡
	2.如果学到的路由都是通过3类LSA学到的域间路由:直接比较开销值.优先选择开销值小的路由,如果两条路由的开销值相同,则负载均衡
	3.如果学到的路由是通过5类LSA获取的域内路由:此时涉及E TYPE和沿途开销值
		#E TYPE:1	则传递的是度量值是种子度量值+沿途累加度量值
		#E TYPE:2	则传递的是度量值为种子度量值
		#E TYPE 1和E TYPE 2之间存在一个优选规则,默认类型1永远优于类型2
		
		如果是E TYPE 2则:
		①优先比较种子度量值,并选择种子度量值小的
		②如果种子开销值相同,则比较沿途开销,选择沿途开销值小的
		③如果两条LSA5/7到达的沿途开销也相同,则负载均衡
		
		如果是E TYPE 1则:
		①优先比较总开销值(种子度量值+沿途开销值),并选择总开销值小的
		②如果总开销值相同,则,则负载均衡
	
	不同类型的LSA之间比较:
		1.域内和域间:域内路由(通过1.2.3类LSA学到的)优先级高于域间路由(通过3类LSA学到的)
		2.域间和域外:域间路由优先级高于域外路由(通过5类,7类LSA学到)
		3.五类和七类:可以看成一种,5类LSA和7类LSA开销值相同也会负载均衡
```

###### OSPF防环

```shell
域间防环:
	1.星型拓扑的区域划分就是一种防环
	2.区域之间存在水平分割(区域水平分割,从哪个区域学到的东西将不再发送回去这个信息)

域内环路:
	由于OSPF区域内部传递的是拓扑信息,需要通过SPF算法计算路由条目.所以域内的防环主要依靠SPF算法(最短路径优先算法)
	OSPF实际使用的算法是I-SPF(实际是SPF的一个改进版本)
	1.I-SPF:
```

###### 重发布

```shell
作用:
	在网络中,若运行多种路由协议或者相同协议的不同进程因为协议之间不能直接沟通计算,进程之间也是独立进行运转和计算的,所以需要重发布来实现路由共享

条件: 
	1.必须存在ASBR(同时连接两种协议/同时运行两个进程,同时学到两边路由,之后进行路由共享)
	2.必须关注种子度量值(起始度量,A协议和B协议的度量计算标准不同,无法直接导入使用。所以在A协议重发布到B时,ASBR不会使用A协议所使用开销值,而是在导入到B协议时重新使用一个新的起始度量值)

规则:
	1.将A协议重发布到B协议时,在ASBR上的B协议进行配置
	2.将A协议发布到B协议上,是将①ASBR上所有通过从A协议学习到的路由,及②ASBR上宣告在A协议的所有直连网段的路由,都全部共享到B协议中

重发布的部分概念
点(ASBR个数)
	单点:两个协议/两个进程之间存在1个ASBR
	双点:两个协议/两个进程之间存在2个ASBR
	多点:两个协议/两个进程之间存在多个ASBR
向(重发布方向)
	单向:一个协议/进程单方面导入另外一个协议/进程(仅A协议共享到B中)
	双向:一个协议/进程双方面导入另外一个协议/进程(A,B协议的路由互相共享)

配置:
A.单点单向重发布:
	1.RIP
	A协议——>B协议:一种动态路由协议共享到另一种动态路由协议中
	#RIP在进行重发布导入到其他的路由协议后,会将其种子度量值设置为0
	#RIP的种子度量值是可以修改
		#①直接在ASBR的进程中修改种子度量值(这个修改将修改所有往RIP进程中重发布的路由信息)
		#②在ASBR进行重发布进程中导入过程修改度量值(这个修改仅影响这次重发布导入的路由信息)
	#注意,如果同时存在使用两种冲突命令,则会优先匹配更精确的命令来执行
	静态协议——>B协议:将ASBR上的静态路由共享到动态路由协议中
	#重发布过程中无法导入缺省路由(只能自己配置)
	#种子度量值默认为0,修改方法同上
	直连协议——>B协议:将ASBR上的直连路由共享到动态路由协议中
	#①除了本地直连路由外,其他的重发布的直连网段都会导入
	#②直连导入的默认种子度量值默认为0(可以修改)
	#③若ASBR进行了A——>B和直连路由的重发布,且里面包含相同的路由信息,则优先选择直连重发布的路由信息而不看开销值
	2.OSPF
	A协议——>B协议:一种动态路由协议共享到另一种动态路由协议中
	#OSPD重发布获取其他协议路由时,会将种子度量值设为1,度量值类型为2，修改种子度量值和开销值的方式
	#以下两种方法将会影响所有导入的OSPF进程的路由种子度量值和开销值类型
		#在ASBR的OSPF进程中,修改默认种子度量值
		#在ASBR的OSPF进程中,修改默认开销值类型
	#以下两种方法仅影响本次导入的OSPF进程的路由种子度量值和开销值类型
		#在ASBR的OSPF进程中,修改默认种子度量值
		#在ASBR的OSPF进程中,修改默认种子度量值
	静态协议——>B协议:将ASBR上的静态路由共享到动态路由协议中
	#重发布过程中无法导入缺省路由(只能自己配置)
	#种子度量值默认为1,开销值类型为2,,修改方法同上
	#缺省配置:defalt-route-advertise(实质是将路由表中的缺省路由重发布到OSPF进程中)
	直连协议——>B协议:将ASBR上的直连路由共享到动态路由协议中
	#①除了本地直连路由外,其他的重发布的直连网段都会导入
	#②直连导入的默认种子度量值默认为0(可以修改)
	#③若ASBR进行了A——>B和直连路由的重发布,且里面包含相同的路由信息,则优先选择直连重发布的路由信息而不看开销值
	
B.双向双点重发布
	路由回馈:若进行RIP和OSPF进行双点重发布,由于RIP和OSPF的默认优先级不一致,而第一台ASBR重发布结束后,将会影响到其他ASBR设备的路由表。使得路由可能被传回源协议,发生路由回馈(A协议路由重发布到B协议后,又被协议重发布到A协议)
	路由回馈会造成选路不佳,甚至产生环路。而为了消除路由回馈,华为设备消除方式是将OSPF协议内部的默认优先级设置为10,重发布进来的路由(5/7类LSA)的优先级设置为150。 #优先级为150大于所有IGP协议的优先级,然后避免路由回馈的产生
	在多点重发布中,由于重发布的种子度量值问题,必然导致选路不佳只能依赖路由策略来人为干涉选路

路由策略:在控制层流量抓发的过程中,截取流量,之后修改流量中的参数/不转发,最终影响路由器路由表的生成,以达到干涉选路的目的	#(ACL主要是数据层流量抓取控制)
	#控制层流量:路由协议发送路由信息时,产生的流量
	#数据层流量:设备访问目标地址时,产生的流量	
	①抓取流量(控制层流量)
		a.通过ACL列表进行抓取(本身用于限制数据层流量的进出,也可以用于抓取控制层流量,但是由于通配符的原因,无法准确匹配控制层流量)
		b.通过前缀列表进行抓取(IP-Prefix):可以抓取到网段信息
		#前缀列表的规则是以10为步调自动添加(便于插入和删除规则),匹配规则:自上而下,逐一匹配,一旦匹配成功将按照该规则执行,而不在向下匹配。末尾隐含拒绝所有！！！
		#前缀列表还可以进行范围匹配
	②路由策略
	a.RIP的merticin和merticout  偏移列表
	只能应用在距离矢量型协议上,链路状态协议是无法使用的
	b.filter-policy		过滤列表
	可以在距离矢量协议上使用,也可以在链路状态型协议中使用。但是在链路状态协议中,在一个area中,因为没有办法过滤拓扑信息，所以只能在入方向调用，用来影响自身，并且只是在路由加表时不向路由表加表,并不是将拓扑信息过滤掉
	而如果想要在出方向进行调用,可以在ABR/ASBR上针对3.5类LSA进行修改
	c.route-policy		路由策略
		①抓流量
		②部署路由策略
		③在重发布中进行调用
	#匹配规则:自上而下,逐一匹配,一旦匹配成功将按照该规则执行,而不在向下匹配。末尾隐含拒绝所有！！！
	#route-policy即是拒绝一个流量,在抓取时也使用允许,之后在路由策略中进行拒绝
	#route-policy的一条规则中，若没有流量匹配动作,则代表匹配所以流量；如果没有相应的应用，则仅对流量执行大动作;因此大动作为允许的空表，代表允许所有。
```

### BGP

```shell
边界网关协议
	IGP:内部网关协议(RIP,OSPF)
	EGP:外部网关协议(BGP)
#依据AS自治系统来区分外部与内部网关协议，由单一的机构/组织所管理的一系列IP网络及设备所构成的集合
划分AS的原因:
	1.网络范围太大,协议收敛较慢
	2.自治管理
为了方便对自治系统的管理,给每个自治系统设置一个号(AS号：0-2^16)其中0和65535为保留，所以可以范围:1-65534，而其中64512-65534被设定为私有AS号，剩下的为公有AS号
	因为传统的AS号不够用,所以目前大部分设备均支持扩展AS号(32位二进制构成)
	BGP协议，目前在IPV4环境下主要使用BGPV4，也存在BGPV4+(在BGPV4的基础上,支持多种地址族)
	
AS间相互获取路由信息可以使用重发布,但是以重发布作为解决方案存在的问题:
	1.选路不佳：重发布导入路由时会刷新开销值
	2.ASBR的归属问题(ASBR会保存两个AS的信息,且ASBR的成本较高)
	
BGP协议是无类别的路径矢量协议(区别距离矢量协议和路由协议)
	无类别:传递路由信息携带子网掩码
	距离矢量:
	①距离矢量中的距离指的是协议将一个路由器作为一跳来计算开销，路径矢量是以一个AS作为一个单位来传递信息的
	②距离矢量型协议是根据算法来区分,BGP不存在算法的概念,因为BGP不需要去计算路由，只需要将现有路由传递到自己的邻居即可

IGP的评判标准(选路佳，收敛快，占用资源少)
EGP的评判标准:
①可控性：(AS之间需要传递大量的路由信息,EGP可以方便的干涉选路，更容易做策略)，以弥补重发布的不足
	#为了保证路由传递的可控性,更方便干涉选路,BGP舍弃了开销值,取而代之的是为他选路信息设计了很多路径数据.可以通过属性进行选路,使得选路更加灵活,可控性更高
②可靠性：(BGP为了保证传输的可靠性,直接选择使用TCP协议作为传输层协议来完成数据收发。TCP的179号端口)
	#使用TCP协议通讯的问题：传输效率较低，且只能实现单播通讯(TCP需要建立会话)，占用资源大。所以使用TCP便不能通过广播和组播去发现邻居进行通信
	#BGP协议可以实现非直连建邻,非直连建邻的前提条件是邻居双方网络可达(BGP的非直连建邻是建立在IGP的基础上)
	#可以根据邻居关系（对等体）的建立情况，将BGP的邻居关系分为两种(AS之间，AS内部)
	#AS之间：EBGP对等体（建立对等体的两台路由器位于不同AS中，则他们的关系被称为EBGP对等体关系）
	#AS内部：IBGP对等体（建立对等体的两台路由器位于同一个AS中，则他们的关系被称为IBGP对等体关系）
		#EBGP对等体之间的一般采用直连建邻的方式，使用EBGP的TTL为1;IBGP对等体之间需要非直连建邻，所以IBGP对等体之间的TTL为255。如果EBGP对等体之间需要非直连建邻,则需要手工修改TTL	(非直连建邻的前提条件是邻居双方网络可达)
③AS-BY-AS：BGP将AS作为一个单位来看待，BGP不支持负载均衡
```

###### BGP的数据包

```shell
在BGP中由手工指定邻居关系来进行OSPF的发现邻居任务
在BGP中由OPEN包来进行OSPF的建立邻居的任务
在BGP中由Keeplive包来进行OSPF的保活邻居的任务

数据包是在TCP连接下进行传输的

Open包
	Open包主要用来建立邻居，而建立邻居关系需要几个确认
	AS号:在手工建立邻居关系时，声明的邻居的AS号，对端收到后，会检查其是否和本地AS号一致，一致则正常建立邻居关系（对等体）
	认证:BGP也可以在建邻时做认证,需要比对双方的认证口令，不一致则无法建立邻居关系（对等体）
	Route-ID:主要为了区分和标定路由器.open包携带RID的目的是为了确保双方的RID不一致(确保其唯一性,如果相同则无法建立邻居关系)
	#RID是由32位二进制构成，并且遵循IP地址的格式，可以通过是手工配置和自动获取
	#先在自己的路由器的环回接口中选择最大的IP地址作为RID，如果没有环回接口则再物理接口中选择IP地址最大的作为RID
	#在接受邻居数据包时，其中的源ip必须和手工指定的邻居的ip地址一致才可以正常建立邻居关系(这个地址将作为之后的更新源地址)
	OPEN包在建立邻居关系的时候会携带保活时间(hold time)这个参数默认为180s（双方建邻时携带这个值，但并不要求必须相同），但是在执行时，必须相同（选择保活时间较小的作为执行时间）
	#180s内若收不到对方发送的Keeplive包/Update包，则会刷新计时器；若收不到则判定BGP链接中断（TCP中断）
	OPEN包中也会将自身是否支持路由刷新功能等相关参数进行携带，双方进行协商，如果都支持则开启路由刷新功能
	
Keeplive包
	keep包的发送周期为1/3的hold time (hold time默认180s)
	Keeplive包主要就是周期保活TCP会话，不需要携带太多的参数，也不具备太多的功能
	Keeplive包还有一个作用就是在接收到对方发送的OPEN包后，临时充当确认包的作用		主要是用来确认OPEN包的数据参数，如果认同对方的参数则回复keeplive包进行确认
	
Update包
	更新包，携带路由信息的数据包(包括目标网段，子网掩码信息，以及BGP的各种属性)
	在UPdate包中存在有撤销路由字段,可以在直接不可达的路由信息放在该字段下进行通告，以达到传递失效信息的目的.而不像RIP一样带毒传输
	
Notification包
	BGP包的错误纠察包


Route-refresh包
	不常用，用于改变路由策略后请求对等体重新发送路由信息
	#前提要求对等体双方均支持路由刷新
```

BGP的状态机

```shell
	BGP的状态机只是描述BGP对等体建立过程中的状态变化。因为BGP可以做到建立邻居关系和发布路由分开完成

IDLE状态(空闲状态)  
	一开始启动BGP之后,先处于IDLE状态，之后手工指定邻居关系
	#当手工指定好邻居之后,BGP将开启检查步骤.需要确认指定的IP地址在本地路由表中是否路由可达,如果可达，则开始尝试建立TCP会话,进入下一个状态;如果不可达，则停留在IDLE状态

connect状态(连接状态)  
	进行TCP会话的连接状态。如果TCP建立成功则进入OPENsent状态;如果TCP建立失败则停留在Active状态
	#在建立TCP会话连接时，双方都会尝试连接，一方建立成功则将创建一个双向的TCP通道；双方都建立成功则会出现两个双向通道。需要关闭其中的一个TCP通道，后面发送OPEN包，其中携带RID，仅保留RID大的一段发起的TCP连接,RID小的一段发起的TCP通道将会被断开
	
OPENsent状态(开始发送状态)
	开始发送OPEN报文,报文中携带建立邻居关系所需的参数，报文携带建立邻居关系所需的参数。当收到对端发送的OPEN包，将进行参数检查，如果参数没有问题则会回复一个keeplive包作为确认,则进入openconfirm状态
	
OPENconfirm状态(open确认状态)
	对端收到本端的OPEN包，在确认参数无误后，则发送keeplive包进行确认。此时则代表双方的OPEN包中的参数都确认无误就进入Established状态
	
Established状态(建立完成状态)
	标志对等体建立完成
```

###### BGP的工作过程

```shell
	1.基于IGP（静态，直连）实现IP可达；
	2.指定邻居关系，邻居间需要建立TCP会话通道。BGP之后发送的所有数据包都是通过TCP会话通道发送，来保证其传输的可靠性的。
	3.使用OPEN报文和keeplive报文进行邻居关系的建立；生成邻居表；
	4.使用Update报文共享路由信息，信息中携带目标网络号，掩码信息及各种属性；将收集和发送的所有路由信息记录在一张表中---BGP表。
	5.之后，将BGP表中的最优路径加载到路由表中。（到达同一个目标网段可能收到多条路由信息，BGP仅加载一条（不存在负载均衡）最优路径，最优路径是通过属性来选择的）
	6.收敛完成后，将使用keeplive包进行周期保活，默认保活时间为180S，周期发送时间为60S。
	7.若出现错误信息，将使用notification报文进行告警；（这个错误信息可能出现在对等体建立的时候，也可能出现在之后。）
	8.若发生结构突变，则将直接发送UPdate报文进行触发更新。
```

###### BGP的基础配置

```
BGP邻居建立过程:
EBGP:
	1.EBGP对等体直连建邻
		①启动BGP进程
		②配置RID
		③手工建邻(指定邻居和邻居所在AS的编号)
	2.EBGP对等体非直连建邻
	
IBGP:
	由于IBGP邻居处于同一个AS中,正常一个AS中存在大量的备份路径，若使用物理接口建立邻居关系，将浪费这些备份的流量
```

###### BGP的路由发布

```shell
1.通过Network命令进行发布
	BGP可以将所有路由表中存在的路由条目通过NETWOR0K命令进行发布
	#发布的路由信息必须是路由表中有的，不然无法发布
	#而BGP宣告后会有几个数据Nexthop和路由状态码
	#当一条路由器收到来自EBGP对等体发送的路由信息正常加表后,该路由的协议类型为EBGP,优先级为255
	NextHop下一跳，属于BGP的路由属性。谁通告谁就是下一跳；如果是自己发布，则下一跳属性为0.0.0.0
	在Network前面出现的符号称为这条路由的状态码
	 *代表可用:BGP设备每收到一条路由信息，都会检查其下一跳属性的可达性(通过路由查询)。如果下一跳的地址是可达的，则代表该路由可用。不可达则不可用，不可用则该路由信息将不被接纳不参与选择
	 >代表优选:当收到多条到达相同网段的路由信息时,BGP会根据路由属性选择最好的最优的加到路由表中，并且传递给其他的BGP对等体。不优选的则不传递,不加表
	 s代表抑制:一旦路由前面的状态码中添加s标记，则代表该路由不再传递，不再加表
	 i代表不可达:代表该信息是从IBGP对等体学习来的路由
	 #因为BGP存在AS-BY-AS的特性,所以IBGP邻居之间传递路由时，默认不会修改下一跳，可能会导致EBGP传递的路由信息在IBGP邻居处不可达，需要进行一下命令
	 #peer x.x.x.x  next-hop-local
	 ###有悖论

2.通过重发布来发布BGP路由
	当通告的路由数量较大的时候,
	#起源码有三种:
		#network发布的路由 I	(I代表路由起源于IGP协议,包括静态和直连路由)
		#EGP协议发布的路由 e (指的是BGP协议之前的外部网关协议,EGP协议目前暂时不使用了，使用e标签很少见)
		#除了以上两种方式发布的路由 ? (重发布路由的起源码标记就是?)
```

###### BGP的路由聚合

```shell
BGP的路由聚合方式:自动聚合和手工聚合
自动聚合:
	自动聚合完成后会自动在本地路由表上生成一个空接口路由
	#因为自动汇总的问题,所以需要对路由汇总进行精准把握时，手工聚合将是更理想的方案
自动聚合的问题：
	只能聚合到主类，导致产生巨大的路由黑洞
 	只能对重发布的路由生效
手工聚合:
		问题:
		1.手工聚合没有抑制明细路由，导致路由条目没有减少，反而增加
		2.手工汇总的路由条目存在路由属性缺失的问题，尤其是AS——path属性的缺失(AS_PATH是用来防环的，不携带会产生环路)
		#BGP协议的特殊性,导致在一些特殊环境下往往不能将所有的明细路由全部抑制。所以在进行BGP聚合时，往往只是抑制部分路由信息，来实现这个效果，需要使用抑制策略
		因为聚合后路由存在属性丢失的情况,所以在汇总路由后需要格外关注。为此，BGP专门设计了两个聚合相关的属性(ATOMIC_AGGREGATTE,AGGRGATOR)
		ATOMIC_AGGREGATTE是预警属性,聚合路由将会携带(只有将所有明细路由都全部被抑制的汇总路由才会携带),目的是提醒该路由为聚合路由,可能存在属性丢失问题
		AGGRGATOR将会记录执行汇总路由器所在的AS号及RID
```

###### BGP的路由黑洞

```shell
	由于BGP协议可以允许非直连建邻,可能会出现BGP协议跨越未运行BGP协议的路由器，导致BGP路由传递后，在控制层面可达，但是在数据层面时，流量经过未运行BGP协议的路由器，无法通过，形成路由黑洞

解决方案:
	1.让AS内所有的设备都运行BGP协议(对设备要求高)
	2在AS内部运行BGP的设备上向AS内部使用的IGP协议中进行重发布(对设备要求高)
	3.MPLS技术(多协议标签交换技术)解决路由黑洞问题
		#当前工程中主要使用的解决BGP路由黑洞的方案

	BGP为了防止BGP路由黑洞的产生,提出了BGP同步机制(当一台路由器从自己的IGP对等体学习到一条BGP路由时，他不能将这条路由通告给自己的EBGP对等体，除非他又从IGP协议中（包括静态路由）学习到这条路由。也要求IBGP路由和IGP路由同步)
#华为设备默认关闭BGP的同步机制
```

###### BGP的防环机制

```shell
BGP使用的防环机制:水平分割
在BGP中的水平分割分为两种:
	1.EGBP水平分割,专门解决EBGP对等体之间可能出现的环路问题
	2.IBGP水平分割,专门解决IBGP对等体之间可能出现的环路问题
	
EBGP水平分割:
	BGP协议在路由条目中记录所经过的AS编号:AS_PATH
	BGP传输本地数据时带上本地的AS_PATH信息(AS_PATH 1)，然后传递到下一个AS2时，会在传输到下一个AS时，会叠加本地AS_PATH信息发送给下一个AS区域(AS_PATH 2 1)。如果AS接受到的BGP信息携带本地的AS_PATH包含本地的AS号，则将拒绝接受，避免环路产生
	
IBGP水平分割:
	因为BGP的AS-BY-AS的特性，导致AS内部为一个整体,默认情况下，路由属性是不会发生变化的。所以无法使用属性来进行防环
	IBGP的水平分割做法:当一个路由器从一个IBGP对等体学习到某一条BGP路由时,他将不再把这条路由信息通告给其他的IBGP对等体。
	IGBP水平分割可以有效的解决IBGP对等体之间的路由回传造成的环路问题,但是也会引发路由信息传递障碍问题。所以想要避免IBGP水平分割带来的问题,可以让所有AS内部运行BGP的路由器均建立IBGP对等体关系(这种建立全连的IBGP对等体方案也存在问题,并不是最佳解决方案.当一个AS内运行BGP协议的路由器数量较多时，建立全连的邻居关系将造成大量的资源浪费，并降低网络的可扩展性)
	BGP中存在两个技术专门用于解决IBGP水平分割带来的问题：路由反射器和联邦
```

###### IBGP的水平分割解决问题

```shell
	IBGP的水平分割做法:当一个路由器从一个IBGP对等体学习到某一条BGP路由时,他将不再把这条路由信息通告给其他的IBGP对等体。
1.路由反射器:RR
将一台IBGP配置为路由反射器，
	当指定一台设备为路由反射器为RR的同时，必须指定一个或多个邻居成为他的客户，RR和客户之间构成的系统我们称为反射簇（看成一个整体），每一个簇设置一个簇ID（这个反射簇中RR的RID），而没有被定义的邻居被称为非客户（一个区域内可以有多个RR）
	反射规则：
		①如果RR从客户处学来一条IBGP路由，则它将反射给自己所有的客户和非客户（还有EBGP）
		②如果RR从非客户处学来一条IBGP路由，则它将反射给自己所有的客户（还有EBGP），但是不反射给其他的非客户
		③当路由器在进行路由反射时，只反射自己BGP路由中最优的路由（和BGP路由的传递规则相同）

因为IBGP水平分割主要是为了环路产生，而路由反射器反射后相当于打破了IBGP的水平分割规则，将有可能出现路由环路。而为了避免路由环路产生，路由反射器在设计的时候，专门引入了两个属性来避免环路的产生
（Originator_id和Cluster_list --- 起源者ID和簇列表）
	起源者ID：起源者ID就是这条路由信息始发者的RID，当这条路由经过RR反射后，反射出来的路由信息将增加这个属性（第一个反射的RR会增加的这个属性）。如果RR收到一条路由信息存在起源者ID，则不去修改这个属性。当一台设备收到路由信息后，发现里面的起源者ID是自己本地的RID，则将不会接受这条路由信息以避免路由回传
	如果一个AS内部存在多次反射的话，那么一定存在多个反射簇，则每个RR在反射路由信息的时候会在路由信息中的簇列表属性中加入本地的簇ID。
	#这两个属性只是在IBGP内部进行防环的

2.联邦:
	
```

###### BGP的选路原则

| 属性名称         | 传播范围           | 默认值                         | 评判标准       |
| ---------------- | ------------------ | ------------------------------ | -------------- |
| Preferred-Vlaue  | 无法传播，仅本设备 | 0（0-2^16）                    | 越大越优       |
| Local-Preference | IBGP对等体之间     | 100（0-2^32）                  | 越大越优       |
| AS_PATH          | BGP对等体之间      |                                | 记录值越少越优 |
| Origin           | BGP对等体之间      | 起源类型决定                   | I>e>?          |
| MED              | BGP对等体之间      | 默认取值为全局路由表中的开销值 | 越小越优       |

```shell
前提条件:丢弃所有不可用的路由信息（状态码为*）
选路原则:
1.优先Preferred-value属性值最大的路由
	#这个属性是华为私有属性，意为权重。
	Pv属性是本设备选路优先级最高的属性，越大越优。这个属性是不会进行传递的，只能在本设备上进行修改，传递出去的路由条目将不携带这个值（不传递）。即在对端收到这个路由后，这个属性依旧是默认值。
	#单修改Pv值是修改一条线路的优先级（这条线路上所有的线路都会被优选），所以如果想要做需要线路的pv修改，则需要做负载分担
	负载分担：不同的流量走不同的路线，分担单一线路的压力
	#使用路由策略进行流量操作
	
2.优先Local-Preference属性值最大的路由
	LP本地优先级属性，默认为100（越大越优）。LP值是IBGP内部使用的属性，可以在IBGP邻居之间传递，传递到EBGP邻居时将不携带该属性（IBGP内部最常用的属性）
	#可以使用路由策略进行流量修改

	
3.本地始发的BGP路由优于从其他对等体学到的路由
	#本地始发路由的优先级:手动聚合>自动聚合>network>重发布
	#可以使用路由策略进行流量修改

4.优先AS_PATH属性最短的路由
	AS_PATH选路的基本原则:记录AS号越少越优
	①在聚合路由时开启AS_SET后,将不同的AS明细路由用AS号用大括号括起来放入AS_PATHS属性中。但在比较选路时，不管大括号中包含多少个AS号，都会被当做一个来看待
	②在联邦时，联邦内部也需要使用AS来进行防环，会使用小括号表示。这比较选路时，将不考虑小括号中的内容
	#由于添加的AS_PATH号可能会在真实网络中存在。因为AS_PATH属性还可以进行防环，可能会导致添加的AS_PATH无法接受路由信息。
	#可以使用路由策略进行流量修改
	
5.优先Origin属性最优的路由
	#IGP（network）>EGP>其他（重发布）
	#可以使用路由策略进行流量修改
	
6.优先MED值最小的路由
	MED多出口鉴别属性：初始值是继承了IGP协议/静态路由/直连路由在路由表中的开销值，该属性可以影响其他AS的流量如何流入自己的AS中
	#BGP协议在进行宣告时，可以宣告路由表中任意的路由条目，默认将这些路由的开销值继承到BGP路由的MED属性中。若本地宣告的BGP路由传递给EBGP邻居，将携带MED值，便于EBGP邻居所在AS内部的设备进行选路；若本地通过IBGP邻居学到的BGP路由，也将传递给自己的EBGP邻居，但是会将MED值归0传递。因为这个度量值并不是本地产生。即：存在EBGP邻居关系的所有设备都建议宣告内部AS的路由。
	注意：在进行MED比较时，多条相同的路由信息必须来自同一个AS才可以，机AS_PATH中的AS号的最新值必须相同，否则没有可比性
	
7.优先从EBGP对等体学到的路由(EBGP>IBGP)

8.优先到NEXT_Hop的IGP度量值最小的路由
	#到达下一条的本地路由开销值进行比较，与其他参数无关（本地到达的的cost）
	
9.优先Cluster_list短的路由

10.通过起源者ID最小的路由(Originator_id)

11.优先具有最小ip地址的对等体宣告的路由
```

###### BGP的社团属性

```shell
	社团属性类似于路由标签。可以给不同的BGP加入不同社团属。携带社团属性进行通告，便可以根据路由中的社团属性抓取流量，定制策略。
	社员属性本身就是个标签，用来区分路由，由32位二进制构成，写法：①直接十进制表示②十六位:十六位，前十六位是该路由所在的AS的AS号，后十六位自定义编号
	#一条路由可以加入多个社团属性
	
BGP中有几个定义的公认社团属性
	① 0X0000 00000  --- internet
		所有BGP路由默认属于这个名词为“internet”社团中。如果使用路由过滤器匹配社团属性为internet的路由时，将匹配任意一条BGP路由
	② 0XFFF FFF02 --- advertise
		带上这个社团属性的路由将不被通告给其对等体
	③ 0XFFF FFF01 --- no-export
		带上这个社团属性的路由间无法通告给自己的EBGP邻居(不包括联邦的EBGP邻居)
	④ 0XFFF FFF03 --- no-export-subconfed
	 	带上这个社团属性的路由间无法通告给自己的EBGP邻居(包括联邦的EBGP邻居)
	 	
抓社团属性的列表（社团过滤器）
```

### MPLS

```shell
MPRS:多协议标签交换
	包交换：数据组成数据包，在网络中的各个节点传递，最终到达目标(路由转发)
		包交换问题：
			①会查看两张表：路由表和ARP缓存表
			②路由表的匹配原则:最长匹配原则
			③路由器存在递归查找规定
			④IP包头可变长，只能通过软件进行处理
	标签交换：在二层和三层封装之间，添加一个和路由条目存在映射关系的标签，。维护一张记录对应关系和转发接口表。携带标签的数据来到设备上，将先看到标签，之后基于维护的表进行转发，而不在看三层ip数据。
	#因为标签本身短小且定长，所以转发效率高于包交换。但是由于标签交换过程需要压入/弹出标签的动作，所以对包交换效率的提升不明显
	
包交换的优化过程：
	①进程交换：最早期的包交换（每个数据包来到设备都需要基于目标ip查看路由表及ARP缓存表进行转发）
	②快速包交换：基于流的包交换（一次路由多次交换，只有第一个数据包需要执行包交换过程）
	③思考的特快交换（CEF）：对路由表和ARP缓存表中的数据内容进行预读取（路由表中需要递归查找的先递归好）记录在CEF表中。并且CEF表可以支持硬件处理
```

###### 静态LSP搭建

```shell
静态搭建LSP不需要中转LSR有到达的路由信息
LSP搭建：入站LSR,中转LSR,出站LSR

入站LSR：
	①定义设备的LSR-ID（32位二进制类似于RID，但是只能手工配置，一般使用设备的环回地址）
	②激活MPLS
		1.在全局视图下激活MPLS
		2.在接口里面激活MPLS（所有属于MPLS域中的MPLS都需要激活）
	③手工搭建LSP
		#LSP的下一跳必须和路由表中到达的目标网段的下一跳相同
		#out-label出站标签
中转LSR：
	①配置LSR-ID
	②激活MPLS
	③搭建LSP
	#需要和上一个LSR的信息保存相对一致（入站标签，数据进入的识别标签，需要保持一致）
出站LSR：
	①配置LSR-ID
	②激活MPLS
	③搭建LSP
#静态搭建需要在沿途所有的LSR进行配置，任何环节出错都可能导致流量转发中断，而且静态LSP无法基于拓扑变化而自动收敛，当拓扑结构发送变化时，网管需要手动修改。
#静态LSP仅适用于规模较小，并且拓扑稳定的网络
```

###### LDP（标签分发协议）搭建

```shell
服务于MPLS的控制层面

LDP作用：分配标签，传递标签
1.分配标签：激活LDP后，LDP会在本设备上为FEC分配标签（并不是对所有的FEC都分配标签，只对如果是自己是某个FEC的出站LSR时，才会主动分配标签）
分配方式：①有序方式②独立方式
	有序方式：只有自己是FEC的出站LSR时，才会主动分配标签，其他设备分配标签需要先收到FEC和标签的对应关系，之后进行检查（检查自己路由表中是否存在到达这个FEC的路由以及下一跳和通告者是否相同），检查通过后才去分配标签
	#华为默认使用有序分配
	独立方式：设备可以自己自主对FEC分配标签而不需要等待其他设备的通告
2.传递标签：出站LSR将标签和FEC的映射关系传递给下一跳LSR的前提条件：出站LSR和下一跳LSR是LDP对等体关系，而对等体的前提是LSR之间必须建立LDP会话
	LDP对等体关系为两种：本地LDP会话和远程LDP会话
		本地LDP会话：直连的两个设备之间建立LDP会话
		远程LDP会话：并不一定是直连设备，可以提供手工指定的方式去远程建立LDP会话
			#非直连建邻：TCP
	LDP在进行本地LDP会话建立时，不需要手工指定（本地LDP会话会周期性的发送组播hello包进行发现邻居）
	#因为hello包是组播发送，所以传输层只能使用UDP协议进行封装，而不是TCP
	过程：
	①现在LSR上激活LDP协议，我们LSR的接口将开始周期方送hello包来发现LDP对等体
		hello包采用UDP的646号端口进行通讯，源和目标都是646
		hello包中将携带自己的LDP ID和传输地址等
		传输地址默认使用的是配置的LSR-ID，这个传输地址在后续将作为TCP会话建立的通信地址，所以在配置LSR-ID时，一定要保证该地址可用，且IGP要保证彼此间地址可达
		LDP-ID：要求所有激活LDP协议的设备都需要有一个LDP ID，由48位二进制构成。一般构成方式LSR-ID:0(前32位为LSR-ID，后16位为标签空间)
	②双方收到彼此交互的hello包之后，获取到对方的传输地址，之后再基于传输地址去建立TCP会话
		#在建立TCP会话时，会产生双向的TCP通道。而为了避免产生双向通信，此时会先比较双方的传输地址，传输地址大的成为主动方
		#LDP在建立TCP会话之前，也会像BGP一样去检查传输地址的可达性，如果可达则建立连接，如果不可达则不建立。
	③在TCP建立完成以后，传输地址大的一方将优先发送一个初始化报文，这个初始化报文将携带LDP相关的参数。对端收到后，将对这些参数进行检查，如果认可则将发送自己的初始化报文，同时还会发送一个keeplive报文（keeplive代表确认收到的参数）。对端收到初始化报文后，如果认可其中的参数，则将反馈一个keeplive报文作为确认。双方都收到对端的keeplive报文后，则将代表LDP会话建立完成。
	标签传递的方式：DU模式（下游自主模式），DoD模式（下游按需模式）
	#华为默认为DU模式
	#DU模式：下游设备主动发送标签
	#DoD模式：下游设备只有在收到上游设备发送的请求报文之下，才会发送标签
	只有上游设备会去收集下游设备的标签！！！（下游发送标签给上游）

PHP机制（次末跳弹出机制）
	标签在次末跳时弹出，使用特殊标签号（3：隐式空标签，作用：一个LSR看到一个数据的出站标签为3时，则直接把该标签弹出）
	#华为设备开启PHP优化机制
```

###### BGP的路由黑洞解决（MPRS）

```

```

###### MPLS VPN 

```

```

### 三层架构

###### 园区网

```shell
园区网：工厂，政府机关，写字楼，公园等这些公共场所为实现数据互通所搭建的网络都可以称为园区网。不同的园区网搭建的侧重点不同

无线连接需要依靠可以发射和接受无线信号的无线设备，而这些设备最终也需要通过有线接入到网络中
AP：无线接入点
WLAN：无线局域网（广义上指无线电波，激光，红外线等来代替有线局域网的部分或全部传输介质所构建的网络）
无线网天生的缺陷：
①无线信号的穿透性较差
	无线采用的是以太网技术（频分，而民用无线网络使用的是低频频率网段进行数据传输，低频数据网段的先天缺陷穿透性差）
②无线网传输速率和信号强度有关系，而且传输速率指的是双向速率
③无线网络传输效率效率较低，效率较慢
集线器：会产生冲突域，解决方法：CSMA/CD（载波侦听多路访问/冲突检测技术）
	#无线局域网相当于在同一个冲突域中，而无线技术解决冲突采用的是CSMA/CA，效率比CD低
AP：同样也会有冲突域，CSMA/CA（载波侦听多路访问/冲突避免技术）
	#无线设备无法去检查冲突原因：无线信号本身强度动态范围非常大，往往收到的信号强度可能远远小于发出的信号强度，导致检查冲突困难（可以增强硬件性能提高强度）
	CA技术避免冲突的做法：
	①在侦听范围内没有信息发送时，不直接发送信号，而是先给自己设置一个随机计时器
	②CSMA/CA技术采用停等式流控
```

###### 三层网络

```shell
	接入层：主要目的使终端设备接入到网络中来，提供接入端口（一般采用二层交换机，依靠mac地址表实现二层转发）
	汇聚层：主要目的是汇聚接入层收集到的流量，一般采用三层交换机（三层交换机拥有类似普通二层交换机使用的二层接口也拥有类似于路由器或计算机所使用的三层接口。二层口和三层口最大的区别是就是有无ip地址。三层交换机既可以通过MAC地址表实现二层转发，也可以通过路由表实现三层转发）
	核心层：主要作用是完成公网和私网之间数据的快速转发
```

###### 冗余

```shell
冗余（备份），企业网三层架构的核心就是冗余
四类冗余：①线路冗余②设备冗余③网关冗余④UPS冗余
	#UPS（不间断电源）保证企业设备的电源达到99.9999%的可用性
一个真正的三层架构一定会存在冗余
```

###### VLAN

```shell
V：虚拟
LAN：局域网
MAN：城域网
WAN：广域网 
WLAN虚拟局域网：交换机和路由器协调工作后，将原来的一个广播域逻辑上划分为多个

如何VLAN划分
①创建VLAN
	#VID（VLAN ID）区分和标定不同的VLAN，IEEE组织颁布8021Q标准要求VID为12位二进制构成。取值范围从0-4095，其中0和4095为保留位置（取值从1-4094）
②将接口划入VLAN
	VID配置映射到交换机的接口，实现VLAN的划分（一层vlan/物理vlan）
	VID配置映射到数据中的MAC地址，实现VLAN划分（二层vlan）
	VID配置映射到数据中的TYPE字段，实现vlan划分（三层vlan）
	#VLAN还可以根据IP地址/策略进行VLAN划分
③配置接口和干道
```

###### TRUNK/ACCESS/HYBRID标签

```shell
	802.1Q标准设计了VLAN的标签是由四个字节构成，其中包含12位的VID，用来区分不同的VLAN流量，并将这个标签加入到以太网二帧源MAC地址字段和TYPE字段之间
	IEEE802.1Q标准规定，将带有标签的帧称为raggedd帧/802.1Q帧，没带标签的帧我们称为untagged帧
	根据这个特性，将交换机和电脑之间的链路称为ACCESS链路，并且ACCESS链路中交换机中的接口为ACCESS接口。ACCESS链路中只能通过untagged帧，并且这些帧只能属于同一个vlan，电脑只能识别untagged帧
	我们将交换机之间的链路称为trunk接口，trunk链路两端的接口称为trunk接口。trunk链路中允许通过tagged帧，并且这些帧可以属于多个vlan

Link Type 接口类型：	
	①trunk接口
	②access接口
	③hybrid混杂接口
	#华为设备，所有接口默认为hybrid
PVID： 
	华为给每一个接口都需要配置一个PVID，就是接口所属的VID。所有接口没有更改的PVID的接口默认为1

VLAN List： 
	允许通过的vlan列表
	#U代表不带标签untagged ，T代表带标签tagged
华为设备所有通过接口进入到交换机的数据，都必须打上接口所对应的PVID的标签，也就是交换机内部所有的数据都是带标签的

"ACCESS/TRUNK/HYBRID接口在定制转发表时的修改权限是不同的
	ACCESS接口的修改权限：可以修改PVID，也可以允许修改允许列表，出口方式只能是不封装
		#允许列表只能有一个VID，并且必须和PVID相同
	TRUNK接口的修改权限：可以修改PVID，也可以允许修改允许列表，允许列表可以设置为多个VID，出口方式只能是封装
		#允许列表只能有一个VID，如果在允许列表中则固定不带标签	
	HYBRID接口的修改权限：可以修改PVID，也可以允许修改允许列表，允许列表可以设置为多个VID，出口方式也可以修改

`ACCESS接口
	①当ACCESS接口从链路上收到一个untagged帧后，交换机会在这个帧中添加VID为接口PVID为tag，则会判断VID是否在允许列表中，如果在，则对得到的tagged帧进行转发
	②当tagged帧从交换机的其他端口到达ACCESS口后，则交换机会检查这个帧中的tag的VID是否在列表中，如果在则在剥离tag后再从链路中转发，如果不在列表中则丢弃
	③如果ACCESS接口从链路中收到一个tagged帧后，则会直接查看这个数据的标签所属的VID是否在自己的列表中，如果有则转发，没有则丢弃

`TRUNK接口
	①当TURNK接口从链路上收到一个untagged帧，交换机先给数据帧中添加一个VID为PVID的tag，然后再根据VID查看允许列表，如果有则转发，如果没有则丢弃
	②当taggged帧从交换机的其他端口到达TRUNK口后，则交换机会检查这个帧中的tag的VID是否在列表中，如果在则在剥离tag后再从链路中转发，如果不在列表中则丢弃
	#如果VID和TRUNK接口的PVID相同时，则转出时需要剥离标签，如果PVID不相同，则直接转出
	③如果TRUNK接口从链路中收到一个tagged帧后，则会直接查看这个数据的标签所属的VID是否在自己的列表中，如果有则转发，没有则丢弃
	#交换机内需要带标签，所以不能剥离标签

HYBRID接口

```

通过三层交换机来实现VLAN间路由

```shell
SVI（交换机虚拟接口）：交换机上针对不同vlan设置的三层接口
	二层交换机只能存在一个SVI接口，作用是为了远程登录控制设备，
		#二层交换机的SVI接口只能属于一个vlan，这个vlan称为管理vlan
	三层交换机每一个vlan都可以配置一个SVI接口
		#三层交换机具备三层转发功能，所以这个SVI接口可以作为每个VLAN对应的网关接口来使用
```

STP生成树协议

```shell
STP是针对线路冗余
	交换机环路的问题：
	①广播风暴（广播帧在二层环路中形成顺时针和逆时针的环路，并且无线循环，最终导致设备宕机，网络瘫痪）
	②MAC地址表翻摆（MAC地址表漂移）
	③多帧复制

	生成树协议：在二层交换网络中，逻辑的阻塞部分接口实现从根交换机到所有节点唯一的路径，且为最佳路径生成一个没有环路的拓扑，当最佳路径故障时个别阻塞接口打开，以形成备份链路
	
	STP标准的生成树协议（IEEE组织颁布的802.1D标准·最早的生成树·公有）
	还有其他类型的生成树协议：PVST,PVST+（思科的私有生成树协议），RSTP（快速生成树协议·802.1W），MSTP（多生成树协议802.1S）

802.1D生成树一个交换网络一颗树
	STP的数据包：BPDU，B指的是网桥；PDU指的是数据协议单元。BPDU是一种跨层 封装的数据帧，直接封装到二层
	STP中一共存在两种BPDU：①配置BPDU，②TCN BPDU
	①配置BPDU：只有根网桥可以发送，在交换网络初始状态所有交换机均定义本地为根网桥，进行BPDU的发送；之后整个STP网络中所有的设备均收到其他设备的BPDU，然后基于数据包中的参数进行比对，选举根网桥；最后所有非根网桥不再发送BPDU，而仅仅是接受和转发跟网桥发送的BPDU（周期2s，max age 20s）
	②TCN BPDU：本地链路故障后，STP重新收敛为了加快刷新全网所有交换机MAC地址表的记录，将向本地所有STP接口发送TCN BPDU。邻居交换机收到后，先回复TCA标记位1的配置BPDU，用于可靠传输；之后再逐级转发TCN BPDU到根网桥处。然后根网桥回复TC标记位置1的配置BPDU来逐级回复所有交换机（让所有交换机临时将MAC地址表的老化时间从300s修改为15s）
	#非根交换机无法发送配置BPDU，但是可以转发和接受BDPU信息（TCN就是转发时修改配置BPDU信息）
```

###### STP选举

```shell
根网桥（RB）
根端口（RP）
指定端口（DP）
非指定端口（NDP）

BID的优先级
	BID（BID=优先级+MAC地址）
	优先级：2个字节，理论取值范围为0-65535（2^16），但是真实取值范围为0-61440，BID的初始值的默认值为32768[1000.0000.0000.0000]（越小越优）。
	优先级一共16位，但是只使用前4位（所以每一位代表4096），所以在优先级修改的时候，只能按照4096的倍数进行修改。后面的12位是扩展系统ID，在802.1D和802.1W中均保留，只有在802.1S（多生成树协议）中启动

PID的优先级
	PID：接口ID为两个字节（前4位是优先级，后12位为接口编号）
	优先级取值范围0-240，默认值为128，每一位代表16,。在优先级进行修改的时候，只能按照16的倍数来进行修改


根网桥选举：802.1D一个交换网络生成一颗数，一颗树有且仅有一个根
选举方式：比较BPDU中的BID（BID=优先级+MAC地址）	
		#BID是先比较优先级，优先级越小越好；如果优先级相同则比较MAC地址，取MAC地址最小的为根网桥

根端口选举：在每台非根网桥上，有且仅有一个离根网桥最近的接口，用于接收根网桥发送的BPDU
	①先比较接口收到的根网桥发送的BPDU时的开销值
	②当接口的RPC值相同时，则会比较"对端"的（上级）设备的BID，BID小的对应的接口为根端口
	③当对端的BID值相同时，则会比较"对端"的（上级）设备的PID，PID小的对应的接口为根端口
		#PID是先比较优先级，优先级越小越优；如果优先级相同，则比较接口编号，接口编号也是越小越优
	④当对端的PID值相同时，则会比较"本地"设备的PID，PID小的对应的接口为根端口
    	#对端PID相同情况：接集线器

选举指定端口：在每一条存在协议的链路上，有且仅有一个指定端口，原来转发来自根网桥的BPDU
	①存在根端口的链路，根端口对端的端口一定是指定端口，根网桥所有的接口一定是指定端口
	②比较接口出方向的开销值，选择开销值小的为指定端口
	③当接口的开销值相同时，则会比较"本地"设备的BID，BID小的接口为指定端口
	④当本地的BID相同时，则会比较设备的PID，PID小的接口为指定端口
		#本地交换机两个接口插在一起
	⑤当本地的PID相同时，则直接将这个接口堵塞
```

###### STP的接口状态

```shell
"禁用状态"：
	①接口物理关闭，②接口禁用STP生成树协议
"阻塞状态"：
	STP生成树协议激活后接口进入的第一个状态，只能侦听BPDU，不能发生和转发数据，也不能进行MAC地址学习
	#在STP初始化阶段，没有BPDU的发送则接口将等待20s（最大寿命），如果在这个状态下没有收到BPDU则进入下一个状态
"侦听状态"：
	可以发送数据包但是不能转发数据，就是STP生成树角色选举的状态。侦听状态停留15s
	#侦听状态不允许转发数据是因为避免在所以角色没有选举完成时，网络中出现临时环路
	`角色选举结束后，只有根端口和指定端口会进入到下一个状态，非指定端口则将会退回到阻塞状态`
"学习状态"：
	侦听数据帧，并且学习记录Mac地址，但是不转发。学习状态停留15s
	#增加了MAC地址表的学习时间，目的是为了防止未知单播的泛洪
"转发状态"：
	正常接收和转发数据以及BPDU
	
802.1D收敛时间：30s和50s
	首次收敛时间是50s
		#20（初始化状态）+15（侦听）+15（学习）
	拓扑结构变化：①根网桥故障，②直连链路故障
		①根网桥发生故障：20+15+15，需要50s
			#20（故障老化时间）+15（侦听）+15（学习）
		②直连链路发生故障：15+15，需要30s
			#15（侦听）+15（学习），此时已经知道链路故障所以不需要老化时间
			`此时故障交换机没有收到根网桥的BPDU（此时接口处在侦听和学习状态），邻居交换机会发送携带根网桥的BPDU（通过阻塞接口），此时故障交换机会重新侦听学习`
		③非直连发生故障：20+15+15，需要50s
			#20（阻塞链路收不到BPDU信息老化时间）+15（侦听）+15（学习）
			`此时故障交换机会发送的配置BPDU（此时交换机处在阻塞状态），邻居交换机会发送携带根网桥的BPDU（通过阻塞接口），此时故障交换机会重新侦听学习`
```

###### STP配置

```shell
华为设备默认开启STP生成树
```

###### 802.1D的缺点

```shell
①收敛速度慢
②链路利用率低
```

###### PVST

```
基于VLAN的生成树协议
	PVST只是提供了链路利用率的第一个思路，但本身问题解决的也并不彻底，因为一个vlan一颗树如果整个交换网络vlan数量较多，则将导致数的数量过多。因为一棵树每2s都存在一次的配置BPDU的泛洪，将导致流量过大
```

###### RSTP

```
IEEE组织在802.1W中提出的快速生成树，主要解决的是802.1D收敛慢的问题，并没有解决链路利用率低的问题（还是一个交换网络一颗树，可以向下兼容802.1D）
RSTP改进点：
①更改端口的角色
	802.1D端口角色：根端口（RP），指定端口（DP），非指定端口（NDP）
	802.1W端口角色：根端口，指定端口，替代端口（alternate），备份端口（Backup）
	"替代端口和备份端口都是需要被阻塞的端口"
		替代端口：由于学习到'其他交换机'发送的配置BPDU而变成阻塞端口，它提供了从指定端口到根网桥的另一条路径，所以可以作为根端口的备份端口。当一个根端口失效时，则将最优的替代端口成为根端口，直接进入转发状态。
		备份端口：由于学习到'自己交换机'发送的配置BPDU而变成阻塞端口。他们作为指定端口的备份，如果指定端口失效，则备份端口将直接替代指点端口，进入转发状态。
			`交换机下接集线器（拉两根线），此时会阻塞一个接口`
②修改接口了状态
	802.1D接口状态：禁用，阻塞，侦听，学习，转发
	802.1W接口状态：
	丢弃（包含禁用，阻塞，侦听）：不转发用户流量，且不学习MAC地址
	学习：不转发用户流量，也可以学习MAC地址
	转发：既可以转发用户流量，也可以学习MAC地址
③对配置BPDU的报文内容进行了修改
	802.1W使用RST BPDU数据包
	802.1W的P/A机制：快速收敛的重大举措
	#通过P/A机制来保证一个指定接口得以从丢弃状态快速进入转发状态，从而加速了生成树的收敛速度。在P/A机制中存在一个“同步状态”，实际上就是将本地全部接口设置为丢弃状态，防止环路产生
④对配置BPDU的处理逻辑进行修改
	a.在拓扑收敛完成后，配置BPDU不再是只有根网桥主动发送，而是所有非根网桥也会每隔2s发送一个 配置BPDU（发送的内容还是根网桥的配置BPDU）
	b.更短的超时时间
	#在802.1D中，如果一个MAX AGE时间中，如果没有收到配置BPDU则认为上游失效；在802.1W中，一个接口在超时时间内（3个周期：6s）没有收到BPDU，则认为和邻居协商失败
⑤快速收敛机制：
	a.根端口和指定端口的快速切换：利用的是替代端口和备份端口
	b.设置边缘接口：指的是交换机连接终端的接口，因为连接终端，下行接口不会出现环路，所以这些接口可以手工配置成边缘接口，一旦配置成边缘接口后会第一时间切换为转发状态
	#因为边缘接口是人工选择配置，为了避免人为失误，STP存在保护机制：当一个边缘接口收到其他交换设备发送BPDU，则将立即切换为普通接口
	c.引入P/A机制
⑥拓扑变更机制发送变化
	在802.1D中，变更信息需要层层上报至根网桥处，由根网桥下发变更通知（TC置1的BPDU），逐级扩散到整个交换网络，这样存在效率较低；在802.1W中，变更通知将直接由变更点设备发出，直接泛洪致整个交换网络
```

###### 802.1S（MPTP多生成树协议）

```shell
	多生成树为了解决链路利用率低的问题，引入了新的概念（instance 实例），实例可以理解为一个或多个的vlan的集合
	为了区分不同的instance，引入instance ID（由十二位二进制构成，但是实际取值单位为0-4094，根据vlan来划分）
	#华为设备默认存在instance 0，并且默认所以vlan都属于instance 0，之前的BID优先级中的后12位扩展ID就是用来携带instance ID（用来区分不同的instance）
	MSTP引入域（region）概念，类似于OSPF中区域的概念，当一个交换网络过大时，可以将其分为多个MST域。如果网络规模较小时，也可以划分为一个MST域。将交换机划分到同一个MST域中要保证三个参数必须相同：①相同的域名（region name），②相同的修订等级（revision level），③相同的vlan和instance的映射关系

配置：
①交换机中创建vlan
②配置trunk干道
③配置更改生成树模式
	#华为设备默认使用MSTP
④配置MST域
```

###### 链路聚合技术

```shell
	将多个物理接口捆绑成为一个逻辑接口，即将多条物理链路逻辑上聚合成一条链路，可以在不升级硬件设备的条件下达到增加带宽的效果（将多个接口看成一个）
	一般将逻辑链路称为聚合链路（聚合链路在华为中被称为ETH-TRUNK,应用在以太网网络体系下的技术），将多条物理链路称为成员链路，将聚合后的逻辑接口称为聚合接口，将聚合前的物理接口称为成员接口
链路聚合技术限制要求：
	①通道对端必须是同一台设备
	②所有的成员接口应该具有相同的速率，双工模式，相同的类型（access，trunk，hybird），接口放通列表，所属的vlan参数都需要完全相同
	
链路接口的配置：
	①创建接口组
	②将接口划分到接口组
#在华为设备上，为保证所有成员接口的配置相同，要求做链路聚合的成员接口在聚合前不允许做任何配置，只能在聚合后的聚合接口中进行配置
	#华为设备默认使用基于流的负载分担方式进行聚合链路的数据转发。判断数据流的方式有很多，华为设备默认参用基于数据包中的源目IP地址来判断，也可以通过修改接口的数据流判断类型
```

###### VRRP

```shell
虚拟路由器冗余技术
目前VRRP常用版本：VRRP V2（针对IPV4网络）；VRRP V3（针对IPV6）
	在VRRP中存在一个组概念，需要将协同工作的路由器划分到同一个组里，通过配置VRID（8位二进制）来区分不同的VRRP组（一个VRRP组中可以存在多台充当网关的设备，组需要在其中选择一个作为主网关，其他的作为备份网关）
	一个VRRP组需要创建一个虚拟的网关，则需要配置一个虚拟的IP地址
	#注意：①需要手工配置，②需要和真实的物理接口在同一个网段（虚拟网关还会自动生成一个虚拟的MAC地址：0000-5e00-01XX，最后两位16进制也就是8位二进制和组对应的VRID相同）

VRRP的工作过程：
	一旦网关接口配置激活了VRRP，则所有网关都将发送携带参数的VRRP数据包，进行主备关系选举。（先比较优先级，默认值为100，取值范围为0-255，优先级大的为主，其他设备为备份设备；如果优先级相同，则比较接口的IP地址，IP地址大的为主）。选举结束后，只有主会周期发送VRRP数据包（默认为1S
）其他设备仅侦听，如果备份设备在3.6s（超时计算公式：3*周期时间+偏移时间，偏移时间：[256-优先级]/256）中还没有收到主发送的VPPR数据包则将重新选举

	#VRRP默认开启抢占模式（只有优先级参与抢占，抢占模式只比较优先级）
	
在VRRP中，存在检查机制：如果VRRP的上行接口存在故障，则会自动降低优先级来干涉选路
```

### IPV6

```shell
IPV6是由128位的2进制构成，采用的表示方法为：冒分十六进制
XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX -- 首选格式
	#在IPV6的地址表达中，大小写不敏感（A和a一样）
IPV6的简化规则：
①每一段前导0可省略，如果这一段全是0则至少保留一个0，拖尾0不能省略
②一个或多个连续的段为全0时，可以使用“::”来标识，但是注意，一个IPV6地址中只能出现一个“::”
	#在经过简化规则后，可以称为压缩格式
IPV6还有内嵌IPV4地址格式：
	#::192.168.1.1
	
IPV6中也存在网络位和主机位，只是在IPV6中将网络位称为网络前缀，将主机位称为接口标识
在IPV6地址也存在子网掩码标识网络前缀的长度，但是只有简写格式

在网络前缀固定的情况下，后面的接口标识生成方法：
	①手工配置：自己填写一个不会冲突的地址即可
	②通过EUI-64自动生成（使用MAC地址进行标识）
	#1.EUI-64：在48位MAC地址中间（24位的位置），增加FFFE（添加16位），形成一个64位的二进制
	#2.在64位的二进制中，找到第七位取反
	③系统设备随机接口ID
    
在IPV6中，接口支持多宿主：一个接口配置多个不同网段的IPV6地址（地址是不冲突），但是多个接口不能配置同一个网段的IPV6地址（广播域冲突）
	#在华为设备上一个接口不允许配置同一个网段的多个IPV6地址

IPV6地址主要分为3类：单播地址，组播地址，任播地址
	#组播可以模拟广播，所以在IPV6中取消了广播地址
	#任播标识的是一组网络接口，发送一个目标IPV6地址为任播地址的数据包，其效果是发送到该组所有成员接口中距离本地最近的一个接口

IPV6的单播地址：
①GUA：全球单播地址（类似于IPV4的公网地址，可以在全球范围内使用的单播地址）
目前使用的GUA地址范围：2000::/3	（这个地址段分配GUA地址）
	2000:0000:0000:0000:0000:0000:0000:00003FFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF
目前商用IPV6地址段：2001::/16，用于6to4隧道技术的地址段2002::/16
②ULA：唯一本地地址
	#相当于IPV4中的私网地址，但是IPV6不使用NAT技术所以这部分私网地址只是用于私网内实验使用，不允许出现在IPV6公网路由中
	FC00::/7专门为私网地址分配的地址段（目前仅使用了FD00::/8，FC00::/8目前保留后面拓展使用）
③LLA：本地链路地址
IPV4也存在本地链路地址（169.254.0.0/16）
在IPV6中接口是支持多宿主的，每一个接口只要激活了IPV6，就会给自己配置一个LLA地址
固定的网络前缀：FE80::/10（64）[10-64位固定为0]，而后64位按照EUI-64方式自动生成
	#因为IPV6支持多宿主，所以在动态路由协议选择下一跳IP时，处于稳定性考虑会优先选择LLA地址作为下一跳地址	
	
IPV6的组播地址：
	为了标识某个组播组，发送一个目标IP地址作为组播地址的数据包，则该报文将被发送至整个组播组中所有的成员，FF::/8 IPV6组播地址段
	#RIPV2：224.0.0.9		--FF02::9		33:33:00:00:00:01
	#OSPF：224.0.0.5/224.0.0.6					--FF02::5/FF02::6
	#224.0.0.1针对所有的路由器和PC（针对的是所有节点）	--FF02::1
	#224.0.0.2针对所有的路由器						--FF02::2
IPV6组播地址对应的组播MAC地址，前16位为固定值（33:33），组播IPV6地址的后32位为组播MAC地址的后32位
组播地址中还有一种：被请求节点组播地址
	当一个节点具备单播地址后，将自动生成一个被请求节点组播地址（FF02::1:FF前104位固定，后24位就是单播地址的后24位）生成后，被请求节点就会被加入到对应的组播组中

特殊地址：
① :: 全0（128位全0），等同于IPV4的全0，代表没有地址（DHCP请求使用）/所有地址（缺省）
② ::1 环回地址，等同于127.0.0.1
```

###### IPV6相较于IPV4的改进之处：

```
①"无限"的地址空间：IPV6由128位二进制构成
②层次化的地址结构：IPV6地址在分配时会更加合理，更便于进行汇总等操作
③即插即用：相较于IPV4支持DHCP自动获取IP地址，IPV6可以通过SLAAC（无状态地址自动配置技术）开实现快捷的地址下发，不需要DHCP服务器，仅需存在网关并且网关具备IPV6地址即可
④简化报文头部
⑤端到端网络的完整性：在IPV6网络中，不使用NAT技术，所有设备都可以获得唯一的IP地址标识，实现端到端的通讯
⑥安全性增强：为了保证IPV6数据传输的安全，专门研发了一套IPSEC（因特网协议安全协议，一个协议组）目前IPV4也可以配合IPSEC使用，效果同IPV6
⑦增强QoS特性：主要体现在头部FLOW LABEL字段，更方便做QoS（目前字段保留）
```

###### IPV6的配置

```shell
ICMPV6：互联网控制报文协议
	在IPV6体系下，取代ARP协议的是NDP（邻居发现协议），集成在ICMPV6下的，包括无状态地址配置功能也是通过NDP协议来实现的。ICMPV6协议还具备path-MTU发现机制（PMTUD）
	#ICMPV6集成很多功能，所以不同功能的数据报文会通过ICMPV6数据报中的type字段进行区分
	#例如：ping包，echo request（TYPE=128），而回报echo reply（TYPE=129）
	PMTUD：在IPV6路由生成后，设备会发送ICMPV6报文检测包，去检测整条路径中最小的MTU值（PMTU）。之后在发送数据包时按照最小MTU值发送，避免过程中出现分片的现象

一个接口在正式发送IPV6报文之前，将经历3个过程：
	①地址解析
	②DAD （地址冲突检查）
	③地址解析
地址配置：
GUA地址的获取方法：①手工配置，②无状态自动配置（SLAAC-NDP），③有状态自动配置（DHCPV6）
无状态自动配置：无需DHCP服务器，只要有网关便可以让接入IPV6网络中的设备获得IPV6地址，即插即用。当然还存在另外一种形式，网关设备会周期性的主动发送RA报文，携带自己的网络前缀
	#需要ICMPV6中的两种报文：路由请求报文（RS,主机主动发送RS请求，TYPE=133），路由器通告报文（RA，网关回复报文，包含网关的网络前缀，后面的接口标识需要设备自动生成，TYPE=134）
	#华为设备默认关闭自动发送功能
	因为无状态地址配置无法下发DNS等其他的参数信息，所以多应用于物联网等终端较多，且不需要除地址外其他参数的场景

DAD：
DAD和地址解析就是IPV4中ARP协议完成的任务，在IPV6中由NDP协议来完成的
#在NDP完成地址解析时，需要使用两种报文（邻居请求报文（NS），相当于ARP请求报文，type=135；邻居通告报文（NA），相当于ARP应答报文，type=136）
请求报文：
	在ARP中，SIP：自己的IP，DIP：请求的IP
	在NDP中，SIP：自己的IP，DIP：请求IP所对应的被请求节点组播地址
	在ARP中，SMac：自己MAC，DMac：全F
	在DNP中，SMac：自己MAC，DMac：被请求组播地址对应的组播MAC地址
应答报文：
	在APR和DNP中均使用单播回复
```

###### RIP/OSFP

```
RIPNG：组播地址（FF02::9,UDP：520）
	①启动进程
	②在接口内激活RIP
	
OSPFV3：
	①启动进程
	②RID
	③在接口内激活OSPF（带上AS区域）
```

###### IPV4到IPV6的过渡技术

```shell
①GRE隧道来实现IPV6网络的互通
	当IPV6网络过多时，GRE面临的问题
		①需要知道对端的IP地址
		②添加到达对端的路由

②6to4隧道技术
	在IPV6地址中，还存在一种地址（IPV4兼容地址）
	如果拥有一个合法的IPV4地址，则将拥有一段IPV6地址，这些地址就是IPV4兼容地址
	2002:XXXX:XXXX::/48   XXXX:XXXX为IPV4的地址转化过来的地址
	#/48的原因（2002：为/16，IPV4的地址（32位2进制）划分为32位）
	eg:	12.0.0.1 -- 0C00:1 
	
③双栈
```





